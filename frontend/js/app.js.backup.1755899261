// Main application entry point
class SaintEspritApp {
    constructor() {
        this.storage = null;
        this.conductorStorage = null;
        this.newsManager = null;
        this.animationManager = null;
        this.blockManager = null;
        this.conductorManager = null;
        this.templateManager = null;
        this.audioManager = null;
        this.audioEditor = null;
        
        this.currentTab = 'dashboard';
        this.showStartTime = null;
        this.scheduledStartTime = null; // Heure programm√©e de d√©but
        this.isLive = false; // √âtat ON AIR
        this.clockInterval = null;
        this.autoSaveInterval = null;
        this.autoBackupInterval = null;
        this.lastClockUpdate = 0;
        this.cachedSegmentDurations = null;
        this.lastSegmentCacheTime = 0;
        
        // Global state
        this.newsDatabase = [];
        this.animationDatabase = [];
        this.blocksDatabase = [];
        this.conductorSegments = [];
        
        // Optimization flags
        this.isInitialized = false;
        this.audioEditorInitialized = false;
    }

    async init() {
        try {
            console.log('üöÄ Initializing Saint-Esprit...');
            
            // Fix: S'assurer qu'aucun modal n'est actif au d√©marrage
            document.querySelectorAll('.modal').forEach(modal => {
                modal.classList.remove('active');
            });
            
            // Initialize authentication (optionnel)
            try {
                if (window.authManager) {
                    await window.authManager.init();
                    if (window.authManager.isAuthenticated()) {
                        console.log('üë§ Utilisateur connect√©:', window.authManager.getAuthorName());
                    } else {
                        // V√©rifier si on vient de Cognito (pr√©sence du param√®tre code)
                        const urlParams = new URLSearchParams(window.location.search);
                        const hasCode = urlParams.has('code');
                        
                        // V√©rifier si on a d√©j√† essay√© de se connecter (pour √©viter la boucle)
                        const loginAttempted = sessionStorage.getItem('login-attempted');
                        
                        if (!hasCode && !loginAttempted) {
                            console.log('‚ö†Ô∏è Utilisateur non authentifi√© - connexion manuelle requise');
                            // TEMPORAIREMENT D√âSACTIV√â pour debug
                            // sessionStorage.setItem('login-attempted', 'true');
                            // setTimeout(() => {
                            //     window.authManager.login();
                            // }, 1000);
                            // return;
                        } else if (loginAttempted && !hasCode) {
                            console.warn('‚ö†Ô∏è √âchec de connexion - mode non authentifi√©');
                            sessionStorage.removeItem('login-attempted');
                            // Continuer sans authentification pour √©viter la boucle
                        } else if (hasCode) {
                            console.log('üîë Code re√ßu, traitement en cours...');
                            sessionStorage.removeItem('login-attempted');
                        }
                    }
                }
            } catch (authError) {
                console.warn('‚ö†Ô∏è Authentification non disponible:', authError);
                // Continuer sans authentification
            }
            
            // Initialize storage
            this.storage = new Storage();
            await this.storage.init();
            
            // Initialize audio storage
            await initializeAudioStorage();
            
            // Initialize conductor storage
            this.conductorStorage = new ConductorStorage(this.storage);
            await this.conductorStorage.loadConductorsList();
            
            // Check for migration
            // Migration depuis localStorage si n√©cessaire
            if (typeof this.storage.migrateFromLocalStorage === 'function') {
                await this.storage.migrateFromLocalStorage();
            } else if (typeof this.storage.migrateLocalData === 'function') {
                await this.storage.migrateLocalData();
            }
            
            // Initialize managers
            this.initializeManagers();
            
            // Load saved data
            await this.loadData();
            
            // Initialize UI
            this.initializeUI();
            
            // Setup event listeners
            this.setupEventListeners();
            
            // Start background tasks with clock re-enabled
            setTimeout(() => {
                this.startBackgroundTasks();
            }, 2000);
            
            // Check for backups (simplified version that doesn't crash)
            await this.checkAndRecoverBackup();
            
            // MIGRATION: SyncManager d√©sactiv√© - Utilisation d'Amplify Gen 2 temps r√©el
            // Les subscriptions GraphQL remplacent l'ancien syst√®me de sync
            console.log('üì° Synchronisation temps r√©el via AWS AppSync activ√©e');
            
            // Show dashboard by default
            this.showDashboard();
            
            this.isInitialized = true;
            console.log('‚úÖ Saint-Esprit initialized successfully!');
            
        } catch (error) {
            console.error('‚ùå Initialization failed:', error);
            showNotification('Failed to initialize application', 'error');
        }
    }

    initializeManagers() {
        // Initialize content managers
        this.newsManager = new ContentManager('news');
        this.animationManager = new ContentManager('animation');
        
        // Initialize block manager
        this.blockManager = new BlockManager();
        
        // Initialize conductor manager
        this.conductorManager = new ConductorManager();
        
        // Initialize cross user manager
        if (this.storage) {
            this.crossUserManager = new CrossUserManager(this.storage);
        }
        
        // Initialize conductor template manager
        this.conductorTemplateManager = new ConductorTemplateManager();
        
        // Initialize audio manager
        this.audioManager = new AudioManager(this.storage);
        
        // Initialize archives manager
        if (window.archivesManager) {
            window.archivesManager.init();
        }
        
        // Initialize sync manager
        // Utiliser SyncWrapper pour compatibilit√© avec AWS
        // MIGRATION: SyncManager remplac√© par Amplify Gen 2
        // this.syncManager = new SyncWrapper(this.storage);
        this.syncManager = null; // D√©sactiv√© - utilisation d'AppSync
        
        // Initialize audio sync manager
        // MIGRATION: AudioSyncManager remplac√© par Amplify Storage
        this.audioSyncManager = null;
        
        // Initialize S3 audio manager (priorit√© si configur√©)
        this.audioS3Manager = typeof AudioS3Manager !== 'undefined' ? new AudioS3Manager(this) : null;
        
        // Initialize audio sync fix (correctif pour sync audio)
        this.audioSyncFix = typeof AudioSyncFix !== 'undefined' ? new AudioSyncFix(this) : null;
        
        // Initialize audio URL manager (syst√®me par URL simple)
        this.audioUrlManager = typeof AudioUrlManager !== 'undefined' ? new AudioUrlManager(this) : null;
        
        // Initialize audio editor
        this.audioEditor = new AudioEditor();
        
        // Initialize multitrack editor - created on demand
        this.multitrackEditor = null; // Will be created when needed
        
        // Initialize fridge component
        this.fridgeComponent = new Fridge();
        
        // Setup event listeners between managers
        this.setupManagerEvents();
    }
    
    setupSyncEvents() {
        return; // MIGRATION: D√©sactiv√© - remplac√© par subscriptions GraphQL
        if (!this.syncManager) return;
        
        // Update initial sync status in settings
        if (this.settingsComponent) {
            this.settingsComponent.updateSyncStatus({
                status: this.syncManager.lastSyncStatus || 'offline',
                lastSync: this.syncManager.lastSyncTime,
                username: this.syncManager.config.username,
                enabled: this.syncManager.isEnabled,
                interval: this.syncManager.config.interval / 1000,
                conflicts: this.syncManager.conflictQueue ? this.syncManager.conflictQueue.length : 0
            });
        }
        
        // Listen to sync events
        this.syncManager.on('sync-started', () => {
            const indicator = document.getElementById('sync-indicator');
            if (indicator) {
                indicator.textContent = 'üîÑ';
                indicator.title = 'Synchronisation en cours...';
                indicator.classList.add('syncing');
            }
        });
        
        this.syncManager.on('sync-completed', (data) => {
            const indicator = document.getElementById('sync-indicator');
            if (indicator) {
                indicator.textContent = '‚úÖ';
                indicator.title = `Synchronis√© (${new Date(data.time).toLocaleTimeString()})`;
                indicator.classList.remove('syncing');
            }
            showNotification('Synchronisation termin√©e', 'success');
        });
        
        this.syncManager.on('sync-failed', (error) => {
            const indicator = document.getElementById('sync-indicator');
            if (indicator) {
                indicator.textContent = '‚ö†Ô∏è';
                indicator.title = 'Erreur de synchronisation';
                indicator.classList.remove('syncing');
            }
            console.error('Sync error:', error);
        });
        
        this.syncManager.on('sync-conflict', (conflicts) => {
            const count = conflicts.length;
            showNotification(`${count} conflit(s) d√©tect√©(s)`, 'warning');
            
            // Update settings page if open
            if (this.currentTab === 'settings' && this.settingsComponent) {
                this.settingsComponent.updateConflictsList(conflicts);
            }
        });
        
        this.syncManager.on('data-updated', async (data) => {
            // Reload data from storage
            await this.loadData();
            
            // Refresh current view
            if (this.currentTab) {
                this.refreshCurrentView();
            }
            
            showNotification('Donn√©es mises √† jour depuis le serveur', 'info');
        });
    }

    setupManagerEvents() {
        // News manager events
        this.newsManager.on('database-changed', (database) => {
            this.newsDatabase = database;
            this.autoSave();
        });
        
        this.newsManager.on('item-deleted', (item) => {
            this.conductorManager.removeSegmentByItemId(item.id, 'newsId');
        });
        
        // Animation manager events
        this.animationManager.on('database-changed', (database) => {
            this.animationDatabase = database;
            this.autoSave();
        });
        
        this.animationManager.on('item-deleted', (item) => {
            this.conductorManager.removeSegmentByItemId(item.id, 'animationId');
        });
        
        // Conductor manager events - save segments when they change
        this.conductorManager.on('segments-changed', async (segments) => {
            this.conductorSegments = segments;
            await this.saveConductorSegments();
            this.autoSave();
        });
        
        // Block manager events
        this.blockManager.on('blocks-changed', (blocks) => {
            this.blocksDatabase = blocks;
            this.autoSave();
            
            // Refresh editor HTML to update block selectors
            if (this.newsManager.currentId || this.animationManager.currentId) {
                this.initializeEditorHTML();
                
                // Reload current item to preserve form data
                if (this.newsManager.currentId) {
                    this.newsManager.load(this.newsManager.currentId);
                }
                if (this.animationManager.currentId) {
                    this.animationManager.load(this.animationManager.currentId);
                }
            }
        });
        
        // √âcouter tous les √©v√©nements du block manager pour garantir la sauvegarde
        this.blockManager.on('block-created', () => this.autoSave());
        this.blockManager.on('block-saved', () => this.autoSave());
        this.blockManager.on('block-deleted', () => this.autoSave());
        this.blockManager.on('block-items-changed', () => this.autoSave());
        
        // Conductor manager events
        this.conductorManager.on('segments-changed', (segments) => {
            this.conductorSegments = segments;
            this.autoSave();
        });
    }

    async loadData() {
        try {
            const data = await this.storage.load();
            
            // Load databases
            this.newsDatabase = data.news || [];
            this.animationDatabase = data.animations || [];
            this.blocksDatabase = data.blocks || [];
            this.conductorSegments = data.conductor || [];
            
            // Nettoyer les anciens titres de blocks
            this.blocksDatabase = this.blocksDatabase.map(block => {
                // Remplacer les anciens titres par d√©faut
                if (block.title === 'Nouveau Journal' || 
                    block.title === 'New block' || 
                    block.title === 'Nouveau journal' ||
                    block.title === 'New Block' ||
                    !block.title) {
                    block.title = 'Journal';
                }
                return block;
            });
            
            console.log('Loading data:', {
                news: this.newsDatabase.length,
                animations: this.animationDatabase.length,
                blocks: this.blocksDatabase.length,
                conductor: this.conductorSegments.length
            });
            
            // Set in managers
            this.newsManager.setDatabase(this.newsDatabase);
            this.animationManager.setDatabase(this.animationDatabase);
            this.blockManager.setBlocks(this.blocksDatabase);
            this.conductorManager.setSegments(this.conductorSegments);
            
            // Apply settings
            if (data.settings) {
                this.applySettings(data.settings);
            }
            
        } catch (error) {
            console.error('Failed to load data:', error);
            showNotification('Failed to load saved data', 'error');
        }
    }

    async initializeUI() {
        // Render initial lists
        this.newsManager.render();
        this.animationManager.render();
        this.blockManager.render();
        this.conductorManager.render();
        
        // Initialize editor HTML if needed
        this.initializeEditorHTML();
        
        // Update timer display
        this.updateTimerDisplay(this.currentTab);
        
        // Initialize scheduled start time
        this.updateShowStartTime();
        
        // Populate conductor list
        await this.refreshConductorsList();
        
        // Initialize user selectors for cross-user library
        await this.initializeUserSelectors();
        
        // Setup interface based on user role
        const userRole = localStorage.getItem('saint-esprit-role') || 'journalist';
        
        // V√©rifier si on est sur la bonne page
        if (userRole === 'volunteer' && !window.location.pathname.includes('volunteer.html')) {
            window.location.href = '/volunteer.html';
            return;
        }
        
        await this.setupInterfaceForRole(userRole);
    }
    
    async setupInterfaceForRole(role) {
        // Stocker le r√¥le dans l'app
        this.userRole = role;
        
        // Appliquer la classe CSS pour le r√¥le
        document.body.className = `user-role-${role}`;
        
        if (role === 'volunteer') {
            // Interface simplifi√©e pour b√©n√©voles
            this.hideJournalistModules();
            await this.setupVolunteerModules();
        } else {
            // Interface compl√®te pour journalistes
            this.showJournalistModules();
        }
    }
    
    hideJournalistModules() {
        // Masquer les modules complexes pour les b√©n√©voles
        const journalistOnlySelectors = [
            '.conductor-advanced',
            '.news-templates',
            '.animation-scheduling',
            '.advanced-audio-editor',
            '#conductor-section .conductor-actions',
            '.block-selector-dropdown'
        ];
        
        journalistOnlySelectors.forEach(selector => {
            const elements = document.querySelectorAll(selector);
            elements.forEach(el => {
                el.classList.add('journalist-only');
            });
        });
    }
    
    showJournalistModules() {
        // Afficher tous les modules pour les journalistes
        const journalistElements = document.querySelectorAll('.journalist-only');
        journalistElements.forEach(el => {
            el.classList.remove('journalist-only');
        });
    }
    
    async setupVolunteerModules() {
        // Initialiser les modules sp√©cifiques aux b√©n√©voles
        console.log('üéôÔ∏è Mode b√©n√©vole activ√©');
        
        // Cr√©er l'interface d'accueil b√©n√©vole
        this.createVolunteerHomeInterface();
        
        // Phase 2: Initialiser le module StudiosCalendar
        if (window.StudiosCalendar) {
            this.studiosCalendar = new StudiosCalendar(this);
            await this.studiosCalendar.init();
            console.log('‚úÖ Module StudiosCalendar charg√©');
        } else {
            console.warn('‚ö†Ô∏è Module StudiosCalendar non disponible');
        }
        
        // Phase 3: Initialiser le module EmissionEditor
        if (window.EmissionEditor) {
            this.emissionEditor = new EmissionEditor(this);
            await this.emissionEditor.init();
            console.log('‚úÖ Module EmissionEditor charg√©');
        } else {
            console.warn('‚ö†Ô∏è Module EmissionEditor non disponible');
        }
        
        // Phase 4: Initialiser les optimisations
        if (window.VolunteerOptimizations) {
            this.volunteerOptimizations = new VolunteerOptimizations(this);
            this.volunteerOptimizations.init();
            console.log('‚úÖ Optimisations mode b√©n√©vole activ√©es');
        }
    }
    
    createVolunteerHomeInterface() {
        // Cr√©er l'interface d'accueil avec 3 boutons
        const dashboardSection = document.getElementById('dashboard-section');
        if (!dashboardSection) return;
        
        const homeInterface = document.createElement('div');
        homeInterface.id = 'volunteer-home';
        homeInterface.className = 'volunteer-home-interface';
        homeInterface.innerHTML = `
            <h1>üéôÔ∏è Bienvenue dans l'Espace B√©n√©vole</h1>
            <p class="subtitle">Que souhaitez-vous faire aujourd'hui ?</p>
            
            <div class="volunteer-main-buttons">
                <button class="volunteer-action-btn" onclick="app.showVolunteerSection('planning')">
                    <div class="action-icon">üìÖ</div>
                    <div class="action-title">Je consulte le planning</div>
                    <div class="action-desc">Voir la disponibilit√© des studios</div>
                </button>
                
                <button class="volunteer-action-btn" onclick="app.showVolunteerSection('emission')">
                    <div class="action-icon">‚úçÔ∏è</div>
                    <div class="action-title">J'√©cris mon √©mission</div>
                    <div class="action-desc">Cr√©er et √©diter mes √©missions</div>
                </button>
                
                <button class="volunteer-action-btn" onclick="app.showVolunteerSection('audio')">
                    <div class="action-icon">üé§</div>
                    <div class="action-title">J'enregistre ma chronique</div>
                    <div class="action-desc">Enregistrer et √©diter l'audio</div>
                </button>
            </div>
            
            <div id="volunteer-content-area" style="display: none;">
                <button class="btn-back-home" onclick="app.showVolunteerHome()">
                    ‚Üê Retour au menu principal
                </button>
                <div id="volunteer-active-section"></div>
            </div>
        `;
        
        // Ins√©rer au d√©but du dashboard
        dashboardSection.insertBefore(homeInterface, dashboardSection.firstChild);
    }
    
    showVolunteerSection(section) {
        // Masquer l'accueil
        const mainButtons = document.querySelector('.volunteer-main-buttons');
        const contentArea = document.getElementById('volunteer-content-area');
        const activeSection = document.getElementById('volunteer-active-section');
        
        if (mainButtons) mainButtons.style.display = 'none';
        if (contentArea) contentArea.style.display = 'block';
        
        // Masquer tous les panneaux
        const emissionPanel = document.getElementById('emission-panel');
        const calendarPanel = document.querySelector('.studios-calendar-panel');
        
        if (emissionPanel) emissionPanel.style.display = 'none';
        if (calendarPanel) calendarPanel.style.display = 'none';
        
        // Afficher la section demand√©e
        switch(section) {
            case 'planning':
                if (calendarPanel) {
                    activeSection.appendChild(calendarPanel);
                    calendarPanel.style.display = 'block';
                }
                break;
                
            case 'emission':
                if (emissionPanel) {
                    activeSection.appendChild(emissionPanel);
                    emissionPanel.style.display = 'block';
                }
                break;
                
            case 'audio':
                // Afficher l'√©diteur audio
                this.showSection('audio-editor');
                // Adapter l'interface pour les b√©n√©voles
                const audioSection = document.getElementById('audio-editor-section');
                if (audioSection) {
                    audioSection.style.display = 'block';
                    activeSection.appendChild(audioSection);
                }
                break;
        }
    }
    
    showVolunteerHome() {
        // Revenir √† l'accueil
        const mainButtons = document.querySelector('.volunteer-main-buttons');
        const contentArea = document.getElementById('volunteer-content-area');
        
        if (mainButtons) mainButtons.style.display = 'grid';
        if (contentArea) contentArea.style.display = 'none';
        
        // Remettre les panneaux √† leur place d'origine
        const dashboardSection = document.getElementById('dashboard-section');
        const emissionPanel = document.getElementById('emission-panel');
        const calendarPanel = document.querySelector('.studios-calendar-panel');
        
        if (emissionPanel && dashboardSection) {
            dashboardSection.appendChild(emissionPanel);
            emissionPanel.style.display = 'none';
        }
        if (calendarPanel && dashboardSection) {
            dashboardSection.appendChild(calendarPanel);
            calendarPanel.style.display = 'none';
        }
    }

    showDashboard() {
        const today = new Date().toISOString().split('T')[0];
        const allItems = [...this.newsDatabase, ...this.animationDatabase];
        const todayItems = allItems.filter(item => item.scheduledDate === today);
        const readyItems = todayItems.filter(item => item.status === 'ready');
        const urgentItems = todayItems.filter(item => 
            item.status !== 'ready' && item.tags?.includes('urgent')
        );
        
        // R√©cup√©rer le nom de l'utilisateur
        let userName = 'l\'√©quipe';
        if (window.authManager && window.authManager.getCurrentUser()) {
            const user = window.authManager.getCurrentUser();
            // Extraire le pr√©nom du nom complet
            userName = user.fullName ? user.fullName.split(' ')[0] : user.name || user.email?.split('@')[0] || 'l\'√©quipe';
        } else {
            const storedUser = localStorage.getItem('saint-esprit-user');
            if (storedUser) {
                userName = storedUser.split(' ')[0] || storedUser;
            }
        }
        
        const dashboardHTML = this.getDashboardHTML({
            userName: userName,
            progress: Math.round((readyItems.length / todayItems.length) * 100) || 0,
            totalItems: todayItems.length,
            readyCount: readyItems.length,
            urgentItems: urgentItems,
            dayName: ['Dimanche','Lundi','Mardi','Mercredi','Jeudi','Vendredi','Samedi'][new Date().getDay()]
        });
        
        // Cacher toutes les sections
        document.querySelectorAll('.section').forEach(section => {
            section.classList.remove('active');
        });
        
        // Obtenir ou cr√©er la section dashboard
        let dashboardSection = document.getElementById('dashboard-section');
        if (!dashboardSection) {
            dashboardSection = document.createElement('div');
            dashboardSection.id = 'dashboard-section';
            dashboardSection.className = 'section';
            document.querySelector('.main-container').appendChild(dashboardSection);
        }
        
        // Afficher le dashboard
        dashboardSection.innerHTML = dashboardHTML;
        dashboardSection.classList.add('active');
        
        // Mettre √† jour le timer display
        this.updateTimerDisplay('dashboard');
        
        // Mettre √† jour la navigation active
        document.querySelectorAll('.nav-item, .nav-tab').forEach(nav => {
            nav.classList.toggle('active', nav.dataset.tab === 'dashboard');
        });
        
        this.currentTab = 'dashboard';
        
        // Charger les utilisateurs connect√©s
        this.loadConnectedUsers();
    }

    async loadConnectedUsers() {
        const container = document.getElementById('connected-users');
        if (!container) return;
        
        try {
            // Essayer de r√©cup√©rer les utilisateurs depuis le authManager
            if (window.authManager && typeof window.authManager.listUsers === 'function') {
                const users = await window.authManager.listUsers();
                
                // R√©cup√©rer l'utilisateur actuel
                const currentUser = window.authManager.getCurrentUser();
                const currentUserName = currentUser?.fullName || currentUser?.name || localStorage.getItem('saint-esprit-user');
                
                // Formater la liste
                const usersList = users
                    .map(user => {
                        const name = user.name || user.username || 'Utilisateur';
                        const isCurrentUser = name === currentUserName || user.email === currentUser?.email;
                        const status = user.status === 'ACTIVE' || user.lastSeen ? 'üü¢' : '‚ö™';
                        
                        return `<span style="${isCurrentUser ? 'font-weight: bold; color: #00ff9f;' : ''}">
                            ${status} ${name}${isCurrentUser ? ' (vous)' : ''}
                        </span>`;
                    })
                    .join(' ‚Ä¢ ');
                
                container.innerHTML = usersList || '<span style="opacity: 0.6;">Aucun utilisateur connect√©</span>';
                
                // Si on a acc√®s aux donn√©es temps r√©el, s'abonner aux changements
                if (window.realtimeSync) {
                    window.realtimeSync.on('UserActivity_create', () => {
                        this.loadConnectedUsers(); // Recharger quand un utilisateur se connecte
                    });
                }
            } else {
                // Fallback : afficher au moins l'utilisateur actuel
                const currentUserName = localStorage.getItem('saint-esprit-user') || 'Anonyme';
                container.innerHTML = `<span style="font-weight: bold; color: #00ff9f;">üü¢ ${currentUserName} (vous)</span>`;
            }
        } catch (error) {
            console.error('Erreur chargement utilisateurs:', error);
            container.innerHTML = '<span style="opacity: 0.6;">Impossible de charger les utilisateurs</span>';
        }
    }
    
    getDashboardHTML(data) {
        return `
            <div class="dashboard-container" style="padding: 2rem; max-width: 1200px; margin: 0 auto; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: calc(100vh - 200px);">
                <div style="text-align: center;">
                    <h1 style="font-size: 3rem; margin-bottom: 1rem; color: #00ff9f;">Bienvenue sur Saint-Esprit, ${data.userName} !</h1>
                    <h2 style="font-size: 1.8rem; margin-bottom: 2rem; color: #ccc;">Syst√®me de Newsroom pour Radio Fid√©lit√©</h2>
                    <p style="font-size: 1.2rem; color: #999; margin-bottom: 3rem;">${data.dayName} ${new Date().toLocaleDateString('fr-FR')}</p>
                    
                    <div style="display: flex; gap: 2rem; justify-content: center; flex-wrap: wrap;">
                        <button class="btn btn-primary" onclick="app.switchTab('news')" style="padding: 1rem 2rem; font-size: 1.1rem;">
                            üì∞ Cr√©er une News
                        </button>
                        <button class="btn btn-primary" onclick="app.switchTab('animation')" style="padding: 1rem 2rem; font-size: 1.1rem;">
                            üéôÔ∏è Cr√©er une Animation
                        </button>
                        <button class="btn btn-primary" onclick="app.switchTab('conductor')" style="padding: 1rem 2rem; font-size: 1.1rem;">
                            üìã Voir le Conducteur
                        </button>
                    </div>
                    
                    <div style="margin-top: 3rem; padding: 1.5rem; background: rgba(0, 255, 159, 0.1); border-radius: 8px; border: 1px solid rgba(0, 255, 159, 0.3);">
                        <h3 style="color: #00ff9f; margin-bottom: 1rem;">üìä Statistiques du jour</h3>
                        <p style="color: #ccc; font-size: 1rem;">
                            ${data.totalItems} √©l√©ments planifi√©s ‚Ä¢ ${data.readyCount} pr√™ts ‚Ä¢ ${data.totalItems - data.readyCount} en pr√©paration
                        </p>
                        ${data.urgentItems.length > 0 ? 
                            `<p style="color: #ff6666; margin-top: 0.5rem;">‚ö†Ô∏è ${data.urgentItems.length} √©l√©ment(s) urgent(s) √† finaliser</p>` 
                            : '<p style="color: #00ff9f; margin-top: 0.5rem;">‚úÖ Aucun √©l√©ment urgent</p>'
                        }
                        <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(0, 255, 159, 0.2);">
                            <h4 style="color: #00ff9f; margin-bottom: 0.5rem;">üë• Utilisateurs connect√©s</h4>
                            <div id="connected-users" style="color: #ccc; font-size: 0.9rem;">
                                <span style="opacity: 0.6;">Chargement...</span>
                            </div>
                        </div>
                    </div>
                <button class="btn btn-primary" style="font-size: 1.25rem; padding: 1rem 2rem;" onclick="app.loadTemplate('${data.dayName.toLowerCase()}')">
                    üìã Charger Template ${data.dayName}
                </button>
            </div>
        `;
    }

    initializeEditorHTML() {
        // News editor HTML
        const newsEditor = safeGetElement('news-editor');
        if (newsEditor) {
            newsEditor.innerHTML = this.getEditorHTML('news');
            
            // Ajouter les event listeners apr√®s cr√©ation du HTML
            setTimeout(() => {
                const newsContent = safeGetElement('news-content');
                if (newsContent) {
                    newsContent.addEventListener('input', () => {
                        this.newsManager.debouncedCalculateDuration();
                    });
                }
                
                // Add event listener for multitrack button
                const multitrackBtn = safeGetElement('multitrack-news-btn');
                if (multitrackBtn) {
                    multitrackBtn.addEventListener('click', () => {
                        console.log('Multitrack button clicked');
                        this.openMultitrackForNews();
                    });
                }
            }, 100);
        }
        
        // Animation editor HTML
        const animationEditor = safeGetElement('animation-editor');
        if (animationEditor) {
            animationEditor.innerHTML = this.getEditorHTML('animation');
            
            // Ajouter les event listeners apr√®s cr√©ation du HTML
            setTimeout(() => {
                const animationContent = safeGetElement('animation-content');
                if (animationContent) {
                    animationContent.addEventListener('input', () => {
                        this.animationManager.debouncedCalculateDuration();
                    });
                }
            }, 100);
        }
        
        // Block editor HTML
        const blocksEditor = safeGetElement('blocks-editor');
        if (blocksEditor) {
            blocksEditor.innerHTML = this.getBlockEditorHTML();
            
            // Add event listener for planned duration field
            const plannedDurationInput = safeGetElement('block-planned-duration');
            if (plannedDurationInput) {
                plannedDurationInput.addEventListener('input', () => {
                    if (this.blockManager && this.blockManager.currentBlockId) {
                        this.blockManager.calculateBlockDuration();
                    }
                });
            }
            
            // Add event listeners for auto-title generation
            const hitTimeInput = safeGetElement('block-hit-time');
            const scheduledDateInput = safeGetElement('block-scheduled-date');
            
            if (hitTimeInput) {
                hitTimeInput.addEventListener('change', () => {
                    if (this.blockManager && this.blockManager.currentBlockId) {
                        this.blockManager.updateAutoTitle();
                    }
                });
            }
            
            if (scheduledDateInput) {
                scheduledDateInput.addEventListener('change', () => {
                    if (this.blockManager && this.blockManager.currentBlockId) {
                        this.blockManager.updateAutoTitle();
                    }
                });
            }
        }
    }

    getEditorHTML(type) {
        const prefix = type === 'animation' ? 'animation-' : '';
        const categoryField = type === 'news' ? `
            <select id="${prefix}category">
                ${Constants.NEWS_CATEGORIES.map(cat => 
                    `<option value="${cat}">${cat.charAt(0).toUpperCase() + cat.slice(1)}</option>`
                ).join('')}
            </select>
        ` : `
            <select id="${prefix}type">
                ${Constants.ANIMATION_TYPES.map(t => 
                    `<option value="${t}">${t.charAt(0).toUpperCase() + t.slice(1)}</option>`
                ).join('')}
            </select>
        `;
        
        // Get available blocks for assignment
        const blocks = this.blockManager ? this.blockManager.getBlocks() : [];
        const blockSelector = blocks.length > 0 ? `
            <div class="block-selector-dropdown">
                <button type="button" class="block-selector-btn" onclick="app.toggleBlockSelector('${prefix}')">
                    <span id="${prefix}selected-blocks-text">üìÅ Journaux</span>
                    <span class="dropdown-arrow">‚ñº</span>
                </button>
                <div id="${prefix}block-selector-list" class="block-selector-list" style="display: none;">
                    ${blocks.map(block => {
                        // Extraire les infos du titre si c'est un journal automatique
                        let displayTitle = block.title;
                        let timeInfo = '';
                        if (block.hitTime && block.scheduledDate) {
                            const date = new Date(block.scheduledDate + 'T00:00:00');
                            const formattedDate = date.toLocaleDateString('fr-FR', { 
                                day: 'numeric', 
                                month: 'short' 
                            });
                            displayTitle = `Journal ${block.hitTime} - ${formattedDate}`;
                        }
                        
                        return `<label class="block-selector-item">
                            <input type="checkbox" 
                                   id="${prefix}block-${block.id}" 
                                   value="${block.id}" 
                                   data-color="${block.color}"
                                   onchange="app.updateSelectedBlocks('${prefix}')">
                            <span class="block-color-small" style="background: ${block.color}"></span>
                            <span class="block-name">${sanitizeHTML(displayTitle)}</span>
                        </label>`;
                    }).join('')}
                </div>
            </div>
        ` : '';
        
        return `
            <div class="news-editor">
                <!-- Toolbar compacte -->
                <div class="editor-toolbar">
                    <button class="toolbar-btn" onclick="app.${type}Manager.save()" title="Enregistrer">üíæ</button>
                    <button class="toolbar-btn" onclick="app.preview('${type}')" title="Aper√ßu">üëÅÔ∏è</button>
                    ${type === 'news' ? `
                    <button class="toolbar-btn btn-multitrack" id="multitrack-news-btn" title="√âditeur Multipiste">üéöÔ∏è</button>
                    ` : ''}
                    ${blocks.length > 0 ? `
                    <div class="toolbar-separator"></div>
                    ${blockSelector}
                    ` : ''}
                    <div style="margin-left: auto;"></div>
                    <button class="toolbar-btn btn-delete" onclick="app.${type}Manager.delete()" title="Supprimer">üóëÔ∏è</button>
                </div>
                
                <!-- Wrapper pour les barres d'info -->
                <div class="editor-info-wrapper">
                    <!-- M√©tadonn√©es sur une ligne compacte -->
                    <div class="editor-metadata">
                    <div class="metadata-group metadata-category">
                        <label>Cat.</label>
                        ${categoryField}
                    </div>
                    <div class="metadata-group metadata-author">
                        <label>Auteur</label>
                        <input type="text" id="${prefix}author" placeholder="${type === 'news' ? 'Reporter' : 'Animateur'}">
                    </div>
                    <div class="metadata-group metadata-duration">
                        <label>Dur√©e cible</label>
                        <input type="text" id="${prefix}duration" placeholder="0:00">
                    </div>
                    <div class="metadata-group metadata-status">
                        <label>Status</label>
                        <select id="${prefix}status">
                            <option value="draft">Brouillon</option>
                            <option value="ready">Pr√™t</option>
                            <option value="approved">Approuv√©</option>
                        </select>
                    </div>
                    <div class="metadata-group metadata-tags">
                        <label>Tags</label>
                        <div class="metadata-tags">
                            <label class="tag-checkbox">
                                <input type="checkbox" id="${prefix}tag-urgent">
                                <span>üö®</span>
                            </label>
                            <label class="tag-checkbox">
                                <input type="checkbox" id="${prefix}tag-ready">
                                <span>‚úÖ</span>
                            </label>
                            <label class="tag-checkbox">
                                <input type="checkbox" id="${prefix}tag-recurring">
                                <span>üîÑ</span>
                            </label>
                        </div>
                    </div>
                    </div>
                    
                    <!-- Info de dur√©e toujours visible -->
                    <div class="duration-info">
                    <div class="duration-info-item">
                        <span>üìñ Lecture:</span>
                        <span id="${prefix}reading-time">0:00</span>
                    </div>
                    <div class="duration-info-item">
                        <span>üéµ Sons:</span>
                        <span id="${prefix}sounds-time">0:00</span>
                    </div>
                    <div class="duration-info-item">
                        <span>‚è±Ô∏è Total calcul√©:</span>
                        <span id="${prefix}calculated-duration">0:00</span>
                    </div>
                    <div class="duration-info-item">
                        <span>üìù</span>
                        <span id="${prefix}word-count">0</span>
                        <span>mots</span>
                    </div>
                    <div id="${prefix}total-duration-display" style="display: none;">0:00</div>
                    </div>
                </div>
                
                <!-- Div cach√© pour compatibilit√© -->
                <div id="${prefix}duration-breakdown" style="display: none;"></div>
                
                <!-- Zone principale maximis√©e -->
                <div class="editor-main-content">
                    <input type="text" id="${prefix}title" placeholder="Titre...">
                    
                    <!-- Champs cach√©s pour compatibilit√© -->
                    <input type="hidden" id="${prefix}scheduled-date">
                    <div id="${prefix}last-used" style="display: none;">Jamais</div>
                    
                    <!-- Toolbar de formatage ultra-compacte -->
                    <div class="text-format-toolbar">
                        <button class="format-btn" onclick="app.${type}Manager.formatText('bold')" title="Gras"><b>B</b></button>
                        <button class="format-btn" onclick="app.${type}Manager.formatText('italic')" title="Italique"><i>I</i></button>
                        <button class="format-btn" onclick="app.${type}Manager.formatText('underline')" title="Soulign√©"><u>U</u></button>
                        <div class="toolbar-separator-vertical"></div>
                        <button class="format-btn" onclick="app.${type}Manager.insertBullet()" title="Liste">‚Ä¢</button>
                        ${type === 'news' ? `
                        <div class="toolbar-separator-vertical"></div>
                        <button class="format-btn btn-lancement" onclick="app.newsManager.insertLancement()" title="Lancement">üì¢</button>
                        <button class="format-btn btn-desannonce" onclick="app.newsManager.insertDesannonce()" title="D√©sannonce">üì§</button>
                        ` : ''}
                        <div class="toolbar-separator-vertical"></div>
                        <button class="format-btn" onclick="app.openSoundModal('${type}')" title="Ins√©rer son">üéµ</button>
                        <button class="format-btn" onclick="app.${type}Manager.insertTime()" title="Dur√©e">‚è±Ô∏è</button>
                        ${type === 'news' ? `<button class="format-btn" onclick="app.printNews()" title="Imprimer">üñ®Ô∏è</button>` : ''}
                        <div id="${prefix}duration-display" style="display: none;">
                            <span id="${prefix}total-duration-display">0:00</span>
                        </div>
                    </div>
                    
                    <!-- Zone de texte maximis√©e -->
                    <textarea id="${prefix}content" placeholder="Commencez √† √©crire votre ${type === 'news' ? 'news' : 'animation'}...

Raccourcis:
‚Ä¢ **texte** pour le gras
‚Ä¢ *texte* pour l'italique  
‚Ä¢ __texte__ pour le soulign√©
‚Ä¢ [SON: nom - dur√©e] pour les sons"></textarea>
                    
                    <!-- Panel sons (cach√© par d√©faut) -->
                    <div class="sounds-panel" id="${prefix}sounds-panel" style="display: none;">
                        <div id="${prefix}sounds-list" class="sounds-list"></div>
                    </div>
                </div>
            </div>
        `;
    }

    getBlockEditorHTML() {
        return `
            <div class="blocks-editor">
                <!-- Toolbar compacte -->
                <div class="editor-toolbar">
                    <button class="toolbar-btn" onclick="app.blockManager.save()" title="Enregistrer">üíæ</button>
                    <button class="toolbar-btn" onclick="app.blockManager.openAssignModal()" title="Assigner des √©l√©ments">üìé</button>
                    <div style="margin-left: auto;"></div>
                    <button class="toolbar-btn btn-delete" onclick="app.blockManager.delete()" title="Supprimer">üóëÔ∏è</button>
                </div>
                
                <!-- M√©tadonn√©es sur une ligne -->
                <div class="block-metadata">
                    <div class="block-metadata-group metadata-time">
                        <label>Heure</label>
                        <input type="text" id="block-hit-time" placeholder="07:00">
                    </div>
                    <div class="block-metadata-group metadata-date">
                        <label>Date</label>
                        <input type="date" id="block-scheduled-date">
                    </div>
                    <div class="block-metadata-group metadata-author">
                        <label>Journaliste</label>
                        <input type="text" id="block-author" placeholder="Nom du journaliste">
                    </div>
                    <div class="block-metadata-group metadata-duration">
                        <label>Dur√©e cible</label>
                        <input type="text" id="block-planned-duration" placeholder="5:00">
                    </div>
                    <div class="block-metadata-group metadata-color">
                        <label>Couleur</label>
                        <input type="color" id="block-color" value="#00ff9f">
                    </div>
                </div>
                
                <!-- Barre d'info des dur√©es -->
                <div class="block-duration-bar">
                    <div class="duration-bar-item">
                        <span>Dur√©e pr√©vue:</span>
                        <span id="block-planned-display">5:00</span>
                    </div>
                    <div class="duration-bar-item">
                        <span>Dur√©e r√©elle:</span>
                        <span id="block-actual-display">0:00</span>
                    </div>
                    <div class="duration-bar-item" id="block-difference-container">
                        <span>Diff√©rence:</span>
                        <span id="block-difference-display">-5:00</span>
                    </div>
                </div>
                
                <!-- Contenu principal -->
                <div class="block-main-content">
                    <!-- Titre automatique -->
                    <input type="text" id="block-title" class="block-auto-title" readonly 
                           placeholder="Journal de [heure] du [date]">
                    
                    <!-- Section des items assign√©s -->
                    <div class="assigned-items-section">
                        <div class="assigned-items-header">
                            <h4>√âl√©ments assign√©s</h4>
                            <button class="assign-btn" onclick="app.blockManager.openAssignModal()">
                                üìé Assigner
                            </button>
                        </div>
                        <div id="block-assigned-items" class="assigned-items-list">
                            <!-- Items will be rendered here -->
                        </div>
                    </div>
                    
                    <!-- Zone de description -->
                    <div class="block-description-section">
                        <div class="block-description-header">
                            <h4>Sommaire</h4>
                            <span class="word-count" id="block-description-word-count">(0 mots)</span>
                        </div>
                        <textarea id="block-description" placeholder="R√©sum√© du journal..."></textarea>
                    </div>
                </div>
            </div>
        `;
    }

    setupEventListeners() {
        console.log('üîä Setting up event listeners...');
        
        // New sidebar navigation
        const navItems = document.querySelectorAll('.nav-item');
        console.log(`Found ${navItems.length} nav items to attach`);
        
        navItems.forEach((item, index) => {
            const tab = item.dataset.tab;
            console.log(`Attaching listener to nav ${index}: ${tab}`);
            
            item.addEventListener('click', (e) => {
                console.log(`üíÜ Nav clicked: ${tab}`);
                this.switchTab(e.currentTarget.dataset.tab);
            });
        });
        
        // Legacy nav-tab support (if any remain)
        const legacyTabs = document.querySelectorAll('.nav-tab');
        console.log(`Found ${legacyTabs.length} legacy nav tabs`);
        
        legacyTabs.forEach(tab => {
            tab.addEventListener('click', (e) => {
                console.log(`üíÜ Legacy tab clicked: ${e.target.dataset.tab}`);
                this.switchTab(e.target.dataset.tab);
            });
        });
        
        // Search inputs
        const newsSearch = safeGetElement('news-search');
        if (newsSearch) {
            newsSearch.addEventListener('input', Utils.debounce((e) => {
                this.newsManager.search(e.target.value);
            }, 300));
        }
        
        const animationSearch = safeGetElement('animation-search');
        if (animationSearch) {
            animationSearch.addEventListener('input', Utils.debounce((e) => {
                this.animationManager.search(e.target.value);
            }, 300));
        }
        
        // Global keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            this.handleKeyboardShortcut(e);
        });
        
        // Window visibility change
        document.addEventListener('visibilitychange', () => {
            this.handleVisibilityChange();
        });
        
        // Before unload
        window.addEventListener('beforeunload', () => {
            this.cleanup();
        });
        
        // Click outside to close sidebar on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth <= 768) {
                const sidebar = document.getElementById('sidebar');
                const sidebarToggle = document.getElementById('sidebar-toggle');
                
                if (sidebar && sidebar.classList.contains('expanded') &&
                    !sidebar.contains(e.target) && 
                    !sidebarToggle?.contains(e.target)) {
                    sidebar.classList.remove('expanded');
                }
            }
        });
        
        console.log('‚úÖ Event listeners setup completed');
    }

    startBackgroundTasks() {
        // Clock updates
        this.clockInterval = setInterval(() => {
            if (document.visibilityState === 'visible') {
                this.updateClocks();
            }
        }, Constants.CLOCK_UPDATE_INTERVAL);
        
        // Auto-save
        if (safeGetElement('auto-save')?.checked !== false) {
            this.autoSaveInterval = setInterval(() => {
                this.autoSave();
            }, Constants.AUTO_SAVE_INTERVAL);
        }
        
        // Auto-backup
        if (safeGetElement('auto-backup')?.checked !== false) {
            this.autoBackupInterval = setInterval(() => {
                this.createBackup();
            }, Constants.AUTO_BACKUP_INTERVAL);
        }
        
        // Lock cleanup
        this.lockCleanupInterval = setInterval(() => {
            if (this.storage && navigator.onLine) {
                this.storage.cleanExpiredLocks();
            }
        }, 2 * 60 * 1000); // Clean expired locks every 2 minutes
    }

    showConflictsModal() {
        if (!this.syncManager) return;
        
        const conflicts = this.syncManager.getConflicts();
        if (conflicts.length === 0) {
            showNotification('Aucun conflit √† r√©soudre', 'info');
            return;
        }
        
        // Create modal HTML
        const modalHTML = `
            <div id="conflicts-modal" class="modal" style="display: block;">
                <div class="modal-content" style="max-width: 800px;">
                    <div class="modal-header">
                        <h3>‚ö†Ô∏è R√©solution des conflits de synchronisation</h3>
                        <button class="icon-btn" onclick="app.closeModal('conflicts-modal')">‚úï</button>
                    </div>
                    <div class="modal-body" style="max-height: 60vh; overflow-y: auto;">
                        ${conflicts.map(conflict => `
                            <div class="conflict-item" style="border: 1px solid #333; border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                                <h4 style="color: #ff6666; margin-bottom: 0.5rem;">
                                    ${conflict.type === 'news' ? 'üì∞' : conflict.type === 'animation' ? 'üéôÔ∏è' : 'üìã'} 
                                    ${conflict.localItem.title || 'Sans titre'}
                                </h4>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                    <div style="background: rgba(0, 100, 255, 0.1); padding: 0.5rem; border-radius: 4px;">
                                        <strong style="color: #00aaff;">üì± Version locale</strong>
                                        <p style="font-size: 0.875rem; color: #ccc; margin: 0.25rem 0;">
                                            Modifi√© : ${new Date(conflict.localTime).toLocaleString('fr-FR')}<br>
                                            Par : ${conflict.localItem.author || 'Inconnu'}
                                        </p>
                                        <button class="btn btn-primary btn-sm" onclick="app.resolveConflict('${conflict.type}-${conflict.id}', true)">
                                            Utiliser cette version
                                        </button>
                                    </div>
                                    <div style="background: rgba(0, 255, 100, 0.1); padding: 0.5rem; border-radius: 4px;">
                                        <strong style="color: #00ff66;">‚òÅÔ∏è Version serveur</strong>
                                        <p style="font-size: 0.875rem; color: #ccc; margin: 0.25rem 0;">
                                            Modifi√© : ${new Date(conflict.serverTime).toLocaleString('fr-FR')}<br>
                                            Par : ${conflict.serverItem.author || 'Inconnu'}
                                        </p>
                                        <button class="btn btn-secondary btn-sm" onclick="app.resolveConflict('${conflict.type}-${conflict.id}', false)">
                                            Utiliser cette version
                                        </button>
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="app.closeModal('conflicts-modal')">Fermer</button>
                    </div>
                </div>
            </div>
        `;
        
        // Insert modal into DOM
        const modalContainer = document.createElement('div');
        modalContainer.innerHTML = modalHTML;
        document.body.appendChild(modalContainer.firstElementChild);
    }
    
    async resolveConflict(conflictId, useLocal) {
        if (!this.syncManager) return;
        
        await this.syncManager.resolveConflict(conflictId, useLocal);
        
        // Update conflicts count
        const conflicts = this.syncManager.getConflicts();
        const conflictsBtn = document.getElementById('sync-conflicts-btn');
        const conflictsCount = document.getElementById('sync-conflicts-count');
        
        if (conflictsBtn && conflictsCount) {
            if (conflicts.length > 0) {
                conflictsBtn.style.display = 'inline-block';
                conflictsCount.textContent = conflicts.length;
            } else {
                conflictsBtn.style.display = 'none';
                this.closeModal('conflicts-modal');
                showNotification('Tous les conflits ont √©t√© r√©solus', 'success');
            }
        }
        
        // Refresh modal if still open
        if (document.getElementById('conflicts-modal')) {
            this.closeModal('conflicts-modal');
            if (conflicts.length > 0) {
                this.showConflictsModal();
            }
        }
    }
    
    refreshCurrentView() {
        // Refresh the current tab's content
        if (this.currentTab === 'news') {
            this.newsManager.refresh();
        } else if (this.currentTab === 'animation') {
            this.animationManager.refresh();
        } else if (this.currentTab === 'conductor') {
            this.refreshRundown();
        } else if (this.currentTab === 'blocks') {
            this.blockManager.refreshBlocksList();
        }
    }
    
    getMultitrackEditor() {
        if (!this.multitrackEditor) {
            console.log('Creating MultitrackEditor on first use...');
            this.multitrackEditor = new MultitrackEditor();
            // Don't init here, let it be done when actually needed
        }
        return this.multitrackEditor;
    }
    
    async openMultitrackFromNav() {
        // Open multitrack with a blank project or last project
        console.log('Opening multitrack from navigation...');
        
        // First ensure multitrack is initialized
        if (!this.multitrackEditor) {
            await this.initializeMultitrack();
        }
        
        // Check if there's an existing linked news
        if (!this.multitrackEditor.linkedNewsId) {
            // Create a blank project
            await this.multitrackEditor.linkToNews(
                null, // no news ID
                'Projet Libre', // title
                '3:00', // default 3 minutes duration
                '', // no text
                null // no existing audio
            );
        }
        
        // Switch to multitrack view
        this.switchTab('multitrack');
        
        // Make sure the news editor panel is visible
        const newsEditor = document.getElementById('multitrack-news-editor');
        if (newsEditor) {
            newsEditor.classList.add('active');
        }
        
        const container = document.querySelector('.multitrack-container');
        if (container) {
            container.classList.add('from-news');
        }
        
        // Force resize after a moment
        setTimeout(() => {
            if (this.multitrackEditor) {
                this.multitrackEditor.resizeCanvas();
                this.multitrackEditor.render();
            }
        }, 100);
        
        showNotification('Multipistes ouvert en mode libre', 'info');
    }
    
    switchTab(tabName) {
        // Handle dashboard specially
        if (tabName === 'dashboard') {
            this.showDashboard();
            return;
        }
        
        // Update active navigation items
        const navItems = document.querySelectorAll('.nav-item, .nav-tab');
        navItems.forEach(nav => {
            nav.classList.toggle('active', nav.dataset.tab === tabName);
        });
        
        // Update sections
        const allSections = document.querySelectorAll('.section');
        allSections.forEach(section => {
            section.classList.remove('active');
        });
        
        const targetSectionId = `${tabName}-section`;
        const section = safeGetElement(targetSectionId);
        if (section) {
            section.classList.add('active');
        }
        
        this.currentTab = tabName;
        
        // Update timer display
        this.updateTimerDisplay(tabName);
        
        // Rafra√Æchir les listes selon l'onglet
        if (tabName === 'news') {
            this.newsManager.render();
        } else if (tabName === 'animation') {
            this.animationManager.render();
        } else if (tabName === 'blocks') {
            console.log('Rendering blocks...');
            // Toujours rafra√Æchir la liste des blocks
            this.blockManager.render();
            if (!this.blocksInitialized) {
                this.initializeBlocks();
            }
        } else if (tabName === 'conductor') {
            console.log('Rendering conductor...');
            this.conductorManager.render();
        } else if (tabName === 'onair' && !this.onAirInitialized) {
            this.initializeOnAir();
        } else if (tabName === 'conductor-print' && !this.printInitialized) {
            this.initializePrint();
        } else if (tabName === 'audio-editor' && !this.audioEditorInitialized) {
            this.initializeAudioEditor();
        } else if (tabName === 'multitrack' && !this.multitrackInitialized) {
            this.initializeMultitrack();
        } else if (tabName === 'fridge' && !this.fridgeInitialized) {
            this.initializeFridge();
        } else if (tabName === 'template-builder') {
            this.initializeTemplateBuilder();
        }
    }
    
    openMultitrackForNews() {
        console.log('Opening multitrack for news...');
        
        // Check if newsManager exists
        if (!this.newsManager) {
            console.error('NewsManager not initialized');
            showNotification('Erreur: NewsManager non initialis√©', 'error');
            return;
        }
        
        // Get current news data
        const currentNews = this.newsManager.getCurrentItem();
        console.log('Current news:', currentNews);
        
        if (!currentNews) {
            showNotification('Veuillez d\'abord cr√©er et sauvegarder une news', 'warning');
            return;
        }
        
        // Save current news first
        this.newsManager.save();
        
        // Get the actual text content from the textarea or from the saved news
        const newsContentElement = document.getElementById('news-content');
        let newsText = '';
        
        // First try to get from textarea (current editing)
        if (newsContentElement && newsContentElement.value) {
            newsText = newsContentElement.value;
        } 
        // Otherwise get from saved news data
        else if (currentNews.content) {
            newsText = currentNews.content;
        }
        
        console.log('News text to transfer:', newsText ? newsText.substring(0, 100) + '...' : 'No text');
        
        // Initialize multitrack editor if needed BEFORE switching
        if (!this.multitrackEditor) {
            this.multitrackEditor = new MultitrackEditor();
        }
        
        // Switch to multitrack section
        this.switchTab('multitrack');
        
        // Initialize and link after DOM is ready
        setTimeout(async () => {
            try {
                // Ensure multitrack is properly initialized
                if (!this.multitrackInitialized) {
                    await this.initializeMultitrack();
                } else if (!this.multitrackEditor.initialized) {
                    await this.multitrackEditor.init();
                }
                
                // Now link the news to multitrack editor with existing audio if present
                await this.multitrackEditor.linkToNews(
                    currentNews.id,
                    currentNews.title,
                    currentNews.duration || '1:10',
                    newsText,
                    currentNews.audioData || null  // Pass existing audio data if available
                );
                
                // Show the news text editor panel
                const newsEditorPanel = document.getElementById('multitrack-news-editor');
                if (newsEditorPanel) {
                    newsEditorPanel.style.display = 'block';
                }
                
                console.log('Multitrack linked to news successfully');
            } catch (error) {
                console.error('Error linking multitrack to news:', error);
                showNotification('Erreur lors de l\'ouverture de l\'√©diteur multipiste', 'error');
            }
        }, 100);
    }

    updateTimerDisplay(tab) {
        const timerDisplay = safeGetElement('main-timer-display');
        if (!timerDisplay) return;
        
        if (tab === 'news' || tab === 'animation' || tab === 'dashboard') {
            timerDisplay.innerHTML = `
                <div class="timer-item">
                    <div class="timer-label">TIME</div>
                    <div class="timer-value" id="current-time">${new Date().toTimeString().substring(0, 8)}</div>
                </div>
            `;
            timerDisplay.classList.add('simple');
        } else if (tab === 'audio-editor') {
            // Audio Editor: afficher seulement ON AIR et TIME (pas de NEXT)
            timerDisplay.innerHTML = `
                <div class="timer-item">
                    <div class="timer-label">ON AIR</div>
                    <div class="timer-value positive" id="on-air-timer">00:00:00</div>
                </div>
                <div class="timer-item">
                    <div class="timer-label">TIME</div>
                    <div class="timer-value" id="current-time">${new Date().toTimeString().substring(0, 8)}</div>
                </div>
            `;
            timerDisplay.classList.remove('simple');
        } else {
            timerDisplay.innerHTML = `
                <div class="timer-item">
                    <div class="timer-label">ON AIR</div>
                    <div class="timer-value positive" id="on-air-timer">00:00:00</div>
                </div>
                <div class="timer-item">
                    <div class="timer-label">TIME</div>
                    <div class="timer-value" id="current-time">${new Date().toTimeString().substring(0, 8)}</div>
                </div>
            `;
            timerDisplay.classList.remove('simple');
        }
    }

    invalidateSegmentCache() {
        this.cachedSegmentDurations = null;
        this.lastSegmentCacheTime = 0;
    }
    
    updateClocks() {
        try {
            const now = new Date();
            const timeString = now.toTimeString().substring(0, 8);
            
            const currentTimeEl = safeGetElement('current-time');
            if (currentTimeEl) {
                currentTimeEl.textContent = timeString;
            }
            
            // Only update complex timers if we're on the relevant tabs
            if (this.currentTab !== 'conductor' && this.currentTab !== 'onair') {
                return; // Skip expensive calculations if not needed
            }
            
            // ON AIR timer - countdown for current segment
            const nextTimerEl = safeGetElement('next-timer');
            if (nextTimerEl && this.conductorManager && this.conductorManager.getSegments) {
            // Cache segment durations for 5 seconds to avoid recalculating every second
            const now = Date.now();
            if (!this.cachedSegmentDurations || now - this.lastSegmentCacheTime > 5000) {
                const segments = this.conductorManager.getSegments();
                this.cachedSegmentDurations = segments.map(segment => ({
                    visible: this.conductorManager.isSegmentVisible(segment),
                    duration: Utils.parseDuration(segment.actualDuration || segment.duration || '0:00')
                }));
                this.lastSegmentCacheTime = now;
            }
            
            // Calculate remaining time for on-air segment
            let totalRemainingSeconds = 0;
            
            // Si on est en mode ON AIR avec un segment actif
            if (this.currentTab === 'onair' && this.onAirComponent && this.onAirComponent.currentSegmentIndex >= 0) {
                const currentIndex = this.onAirComponent.currentSegmentIndex;
                
                // Ajouter le temps restant du segment actuel
                if (this.onAirComponent.segmentStartTime && this.cachedSegmentDurations[currentIndex]) {
                    const segmentDuration = this.cachedSegmentDurations[currentIndex].duration;
                    const elapsed = Math.floor((Date.now() - this.onAirComponent.segmentStartTime) / 1000);
                    const remaining = Math.max(0, segmentDuration - elapsed);
                    totalRemainingSeconds += remaining;
                }
                
                // Ajouter la dur√©e de tous les segments suivants visibles (depuis le cache)
                for (let i = currentIndex + 1; i < this.cachedSegmentDurations.length; i++) {
                    if (this.cachedSegmentDurations[i].visible) {
                        totalRemainingSeconds += this.cachedSegmentDurations[i].duration;
                    }
                }
            } else {
                // Mode conducteur : calculer la dur√©e totale de tous les segments visibles (depuis le cache)
                for (const segmentData of this.cachedSegmentDurations) {
                    if (segmentData.visible) {
                        totalRemainingSeconds += segmentData.duration;
                    }
                }
            }
            
            // Formater et afficher le temps total restant
            const hours = Math.floor(totalRemainingSeconds / 3600).toString().padStart(2, '0');
            const minutes = Math.floor((totalRemainingSeconds % 3600) / 60).toString().padStart(2, '0');
            const seconds = (totalRemainingSeconds % 60).toString().padStart(2, '0');
            nextTimerEl.textContent = `${hours}:${minutes}:${seconds}`;
            
            // Changer la couleur selon le temps restant
            if (totalRemainingSeconds === 0) {
                nextTimerEl.style.color = '#999';
            } else if (totalRemainingSeconds < 300) { // Moins de 5 minutes
                nextTimerEl.style.color = '#ff6b6b';
            } else if (totalRemainingSeconds < 900) { // Moins de 15 minutes
                nextTimerEl.style.color = '#ff8800';
            } else {
                nextTimerEl.style.color = '#00ff9f';
            }
            
            // Supprimer les classes inutiles
            nextTimerEl.classList.remove('negative');
        }
        
        // On Air timer
        const onAirTimerEl = safeGetElement('on-air-timer');
        if (onAirTimerEl) {
            if (this.isLive && this.showStartTime) {
                // Mode LIVE : afficher le temps √©coul√©
                const elapsed = Math.floor((now - this.showStartTime) / 1000);
                const hours = Math.floor(elapsed / 3600).toString().padStart(2, '0');
                const minutes = Math.floor((elapsed % 3600) / 60).toString().padStart(2, '0');
                const seconds = (elapsed % 60).toString().padStart(2, '0');
                onAirTimerEl.textContent = `${hours}:${minutes}:${seconds}`;
                onAirTimerEl.classList.add('positive');
                onAirTimerEl.classList.remove('negative');
            } else if (this.scheduledStartTime) {
                // Mode ATTENTE : afficher le temps restant
                const timeUntilStart = Math.floor((this.scheduledStartTime - now) / 1000);
                if (timeUntilStart > 0) {
                    const hours = Math.floor(timeUntilStart / 3600).toString().padStart(2, '0');
                    const minutes = Math.floor((timeUntilStart % 3600) / 60).toString().padStart(2, '0');
                    const seconds = (timeUntilStart % 60).toString().padStart(2, '0');
                    onAirTimerEl.textContent = `-${hours}:${minutes}:${seconds}`;
                    onAirTimerEl.classList.add('negative');
                    onAirTimerEl.classList.remove('positive');
                } else {
                    // Le temps est d√©pass√©
                    onAirTimerEl.textContent = '00:00:00';
                    onAirTimerEl.classList.remove('negative', 'positive');
                }
            } else {
                onAirTimerEl.textContent = '00:00:00';
                onAirTimerEl.classList.remove('negative', 'positive');
            }
        }
        } catch (error) {
            console.error('Error in updateClocks:', error);
            // Stop the clock interval if there's a persistent error
            if (this.clockErrorCount === undefined) {
                this.clockErrorCount = 0;
            }
            this.clockErrorCount++;
            if (this.clockErrorCount > 5) {
                console.error('Too many clock errors, stopping clock updates');
                if (this.clockInterval) {
                    clearInterval(this.clockInterval);
                    this.clockInterval = null;
                }
            }
        }
    }

    handleKeyboardShortcut(e) {
        // Prevent shortcuts if user is typing in an input
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.contentEditable === 'true') {
            return;
        }
        
        // Function keys navigation (F1-F10)
        const functionKeyTabs = {
            'F1': 'dashboard',
            'F2': 'news',
            'F3': 'blocks',
            'F4': 'animation', 
            'F5': 'fridge',
            'F6': 'archives',
            'F7': 'audio-editor',
            'F8': 'multitrack',
            'F9': 'conductor',
            'F10': 'settings'
        };
        
        // Check for Shift+F9 for ON AIR
        if (e.shiftKey && e.key === 'F9') {
            e.preventDefault();
            this.switchTab('onair');
            return;
        }
        
        if (functionKeyTabs[e.key]) {
            e.preventDefault();
            this.switchTab(functionKeyTabs[e.key]);
            return;
        }
        
        // Ctrl/Cmd + S = Save
        if ((e.ctrlKey || e.metaKey) && e.key === 's') {
            e.preventDefault();
            this.save();
        }
        
        // Ctrl/Cmd + N = New
        if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
            e.preventDefault();
            if (this.currentTab === 'news') {
                this.newsManager.create();
            } else if (this.currentTab === 'animation') {
                this.animationManager.create();
            } else if (this.currentTab === 'blocks') {
                this.blockManager.create();
            }
        }
        
        // ESC = Close modals or collapse sidebar on mobile
        if (e.key === 'Escape') {
            // Close any open modals first
            const activeModal = document.querySelector('.modal.active');
            if (activeModal) {
                activeModal.classList.remove('active');
            } else if (window.innerWidth <= 768) {
                // Collapse sidebar on mobile
                const sidebar = document.getElementById('sidebar');
                if (sidebar) {
                    sidebar.classList.remove('expanded');
                }
            }
        }
    }

    handleVisibilityChange() {
        // Pause/resume background tasks based on visibility
        if (document.visibilityState === 'hidden') {
            // Could pause non-essential tasks here
        }
    }

    async autoSave() {
        if (safeGetElement('auto-save')?.checked === false) return;
        
        try {
            await this.save();
        } catch (error) {
            console.error('Auto-save failed:', error);
        }
    }

    async save() {
        const data = {
            news: this.newsManager.getDatabase(),
            animations: this.animationManager.getDatabase(),
            blocks: this.blockManager.getBlocks(),
            conductor: this.conductorManager.getSegments(),
            settings: this.getSettings()
        };
        
        console.log('Saving data:', {
            news: data.news.length,
            animations: data.animations.length,
            blocks: data.blocks.length,
            conductor: data.conductor.length
        });
        
        await this.storage.save(data);
        
        // Also save conductor segments to conductor storage if a conductor is selected
        await this.saveConductorSegments();
    }

    async createBackup() {
        if (safeGetElement('auto-backup')?.checked === false) return;
        
        try {
            const backup = await this.storage.createBackup();
            
            // Update last backup time
            const lastBackupEl = safeGetElement('last-backup-time');
            if (lastBackupEl) {
                lastBackupEl.textContent = new Date(backup.timestamp).toLocaleString();
            }
        } catch (error) {
            console.error('Backup failed:', error);
        }
    }

    async checkAndRecoverBackup() {
        // Simplified version that doesn't block
        try {
            console.log('[DEBUG] Checking backups (simplified)...');
            
            // Skip backup check entirely for now - it was causing the crash
            // The backup system needs to be redesigned to not block the app
            
            // TODO: Implement a non-blocking backup check system
            // Ideas:
            // - Use Web Workers for backup operations
            // - Check backups after app is fully loaded
            // - Use a simpler backup system (localStorage instead of IndexedDB)
            
            console.log('[DEBUG] Backup check skipped (preventing crash)');
            return;
            
        } catch (error) {
            console.warn('Backup check error (ignored):', error);
        }
    }

    dismissRecoveryNotice() {
        const recoveryNotice = safeGetElement('recovery-notice');
        if (recoveryNotice) {
            recoveryNotice.classList.remove('show');
        }
    }

    getSettings() {
        return {
            radioName: safeGetValue('radio-name') || 'Saint Esprit',
            radioSlogan: safeGetValue('radio-slogan') || 'Professional Broadcasting',
            autoSave: safeGetElement('auto-save')?.checked !== false,
            autoBackup: safeGetElement('auto-backup')?.checked !== false,
            showTimer: safeGetElement('show-timer')?.checked !== false,
            autoUpdateConductor: safeGetElement('auto-update-conductor')?.checked !== false
        };
    }

    applySettings(settings) {
        if (settings.radioName) safeSetValue('radio-name', settings.radioName);
        if (settings.radioSlogan) safeSetValue('radio-slogan', settings.radioSlogan);
        
        const autoSaveEl = safeGetElement('auto-save');
        if (autoSaveEl) autoSaveEl.checked = settings.autoSave !== false;
        
        const autoBackupEl = safeGetElement('auto-backup');
        if (autoBackupEl) autoBackupEl.checked = settings.autoBackup !== false;
        
        const showTimerEl = safeGetElement('show-timer');
        if (showTimerEl) showTimerEl.checked = settings.showTimer !== false;
        
        const autoUpdateEl = safeGetElement('auto-update-conductor');
        if (autoUpdateEl) autoUpdateEl.checked = settings.autoUpdateConductor !== false;
    }

    // Modal handlers
    openSoundModal(type) {
        const manager = type === 'news' ? this.newsManager : this.animationManager;
        if (!manager.currentId) {
            alert(`Please select or create a ${type} item first.`);
            return;
        }
        
        // Reset form and open modal
        const modalId = type === 'news' ? 'sound-modal' : 'animation-sound-modal';
        const modal = safeGetElement(modalId);
        if (modal) {
            modal.classList.add('active');
        }
    }

    openModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.classList.add('active');
        }
    }
    
    closeModal(modalId) {
        const modal = safeGetElement(modalId);
        if (modal) {
            modal.classList.remove('active');
        }
    }

    // Conductor/Rundown methods
    addSegmentModal() {
        const modal = safeGetElement('add-segment-modal');
        if (modal) {
            modal.classList.add('active');
            this.updateSegmentForm();
        }
    }

    updateSegmentForm() {
        const type = safeGetValue('segment-type');
        const formContainer = safeGetElement('segment-form');
        if (!formContainer) return;
        
        let formHtml = '';
        
        // Ajouter l'option de parent pour tous les types sauf block
        if (type !== 'block') {
            const blocks = this.conductorSegments.filter(seg => seg.type === 'block');
            if (blocks.length > 0) {
                formHtml += `
                    <label style="font-size: 0.875rem; color: #ccc; margin-bottom: 0.25rem;">Parent block (optional):</label>
                    <select id="segment-parent-id" class="mb-2">
                        <option value="">-- No parent (top level) --</option>
                        ${blocks.map(block => 
                            `<option value="${block.id}">üìÅ ${sanitizeHTML(block.title)}</option>`
                        ).join('')}
                    </select>
                `;
            }
        }
        
        if (type === 'ad_placeholder') {
            // Directly open the ad placeholder modal
            this.closeModal('add-segment-modal');
            this.conductorManager.openAdPlaceholderModal();
            return;
        } else if (type === 'block') {
            const availableBlocks = this.blocksDatabase.filter(block => 
                !this.conductorSegments.some(seg => seg.blockId === block.id)
            );
            
            if (availableBlocks.length === 0) {
                formHtml += '<p style="color: #999;">No blocks available. Create a block first.</p>';
            } else {
                formHtml += `
                    <select id="segment-block-id" class="mb-2">
                        ${availableBlocks.map(block => 
                            `<option value="${block.id}">${sanitizeHTML(block.title)} (${block.plannedDuration})</option>`
                        ).join('')}
                    </select>
                `;
            }
        } else if (type === 'news') {
            const availableNews = this.newsDatabase.filter(news => 
                !this.conductorSegments.some(seg => seg.newsId === news.id)
            );
            
            if (availableNews.length === 0) {
                formHtml = '<p style="color: #999;">No news items available. Create a news item first.</p>';
            } else {
                formHtml = `
                    <select id="segment-news-id" class="mb-2">
                        ${availableNews.map(news => 
                            `<option value="${news.id}">${sanitizeHTML(news.title)} (${news.duration})</option>`
                        ).join('')}
                    </select>
                `;
            }
        } else if (type === 'animation') {
            const availableAnimations = this.animationDatabase.filter(animation => 
                !this.conductorSegments.some(seg => seg.animationId === animation.id)
            );
            
            if (availableAnimations.length === 0) {
                formHtml = '<p style="color: #999;">No animation items available. Create an animation item first.</p>';
            } else {
                formHtml = `
                    <select id="segment-animation-id" class="mb-2">
                        ${availableAnimations.map(animation => 
                            `<option value="${animation.id}">${sanitizeHTML(animation.title)} (${animation.duration})</option>`
                        ).join('')}
                    </select>
                `;
            }
        } else {
            const defaultTitle = Constants.DEFAULT_TITLES[type] || '';
            const defaultDuration = Constants.DEFAULT_DURATIONS[type] || '0:30';
            
            formHtml += `
                <input type="text" id="segment-${type}-title" placeholder="Title" class="mb-2" 
                       value="${defaultTitle}">
                ${type === 'block' ? 
                    `<p style="color: #999; font-size: 0.875rem; margin-bottom: 0.5rem;">Duration will be calculated from child segments</p>` :
                    `<input type="text" id="segment-${type}-duration" placeholder="Duration (MM:SS)" class="mb-2"
                           value="${defaultDuration}">`
                }
                ${type === 'live' || type === 'package' || type === 'custom' || type === 'block' ? 
                    `<textarea id="segment-${type}-content" placeholder="Notes..." rows="3"></textarea>` : ''}
            `;
        }
        
        formContainer.innerHTML = formHtml;
    }

    async addSegment() {
        const type = safeGetValue('segment-type');
        const parentIdEl = safeGetElement('segment-parent-id');
        const parentId = parentIdEl ? parseInt(parentIdEl.value) || null : null;
        
        let segment = {
            type: type
        };
        
        if (type === 'block') {
            const blockIdElement = safeGetElement('segment-block-id');
            if (!blockIdElement) {
                alert('No blocks available.');
                return;
            }
            const blockId = parseInt(blockIdElement.value);
            const block = this.blocksDatabase.find(b => b.id === blockId);
            if (block) {
                const actualDuration = this.blockManager.calculateBlockDurationSync(block);
                segment = {
                    ...segment,
                    blockId: blockId,
                    title: block.title,
                    duration: block.plannedDuration,
                    actualDuration: actualDuration,
                    blockColor: block.color
                };
                
                // Ajouter le block
                const blockSegment = this.conductorManager.addSegment(segment, parentId);
                
                // Ajouter automatiquement les √©l√©ments enfants du block
                if (block.items && block.items.length > 0) {
                    for (const item of block.items) {
                        if (item.type === 'news') {
                            const news = this.newsDatabase.find(n => n.id === item.id);
                            if (news) {
                                const calculatedDuration = this.newsManager.calculateItemDuration(news);
                                this.conductorManager.addSegment({
                                    type: 'news',
                                    newsId: news.id,
                                    title: news.title,
                                    duration: news.duration,
                                    actualDuration: calculatedDuration,
                                    content: news.content,
                                    author: news.author
                                }, blockSegment.id);
                            }
                        } else if (item.type === 'animation') {
                            const animation = this.animationDatabase.find(a => a.id === item.id);
                            if (animation) {
                                const calculatedDuration = this.animationManager.calculateItemDuration(animation);
                                this.conductorManager.addSegment({
                                    type: 'animation',
                                    animationId: animation.id,
                                    title: animation.title,
                                    duration: animation.duration,
                                    actualDuration: calculatedDuration,
                                    content: animation.content,
                                    author: animation.author
                                }, blockSegment.id);
                            }
                        }
                    }
                }
                
                this.closeModal('add-segment-modal');
                return;
            }
        } else if (type === 'news') {
            const newsIdElement = safeGetElement('segment-news-id');
            if (!newsIdElement) {
                alert('No news available.');
                return;
            }
            const newsId = parseInt(newsIdElement.value);
            const news = this.newsDatabase.find(n => n.id === newsId);
            if (news) {
                // Calculer la dur√©e totale incluant les sons
                const calculatedDuration = this.newsManager.calculateItemDuration(news);
                
                segment = {
                    ...segment,
                    newsId: newsId,
                    title: news.title,
                    duration: news.duration,
                    actualDuration: calculatedDuration,
                    content: news.content,
                    author: news.author
                };
            }
        } else if (type === 'animation') {
            const animationIdElement = safeGetElement('segment-animation-id');
            if (!animationIdElement) {
                alert('No animation available.');
                return;
            }
            const animationId = parseInt(animationIdElement.value);
            const animation = this.animationDatabase.find(a => a.id === animationId);
            if (animation) {
                // Calculer la dur√©e totale incluant les sons
                const calculatedDuration = this.animationManager.calculateItemDuration(animation);
                
                segment = {
                    ...segment,
                    animationId: animationId,
                    title: animation.title,
                    duration: animation.duration,
                    actualDuration: calculatedDuration,
                    content: animation.content,
                    author: animation.author
                };
            }
        } else {
            segment = {
                ...segment,
                title: safeGetValue(`segment-${type}-title`),
                duration: type === 'block' ? '0:00' : validateDuration(safeGetValue(`segment-${type}-duration`)),
                content: safeGetValue(`segment-${type}-content`) || ''
            };
        }
        
        this.conductorManager.addSegment(segment, parentId);
        
        // Rafra√Æchir ON AIR si actif
        if (this.onAirInitialized && this.onAirComponent) {
            this.onAirComponent.refresh();
        }
        
        this.closeModal('add-segment-modal');
    }

    refreshRundown() {
        // Recalculer les dur√©es r√©elles pour tous les segments
        this.conductorSegments.forEach(segment => {
            if (segment.newsId) {
                const news = this.newsDatabase.find(n => n.id === segment.newsId);
                if (news) {
                    const calculatedDuration = this.newsManager.calculateItemDuration(news);
                    this.conductorManager.updateSegment(segment.id, {
                        actualDuration: calculatedDuration,
                        title: news.title,
                        duration: news.duration
                    });
                }
            } else if (segment.animationId) {
                const animation = this.animationDatabase.find(a => a.id === segment.animationId);
                if (animation) {
                    const calculatedDuration = this.animationManager.calculateItemDuration(animation);
                    this.conductorManager.updateSegment(segment.id, {
                        actualDuration: calculatedDuration,
                        title: animation.title,
                        duration: animation.duration
                    });
                }
            }
        });
        
        this.conductorManager.render();
        
        // Rafra√Æchir ON AIR si actif
        if (this.onAirInitialized && this.onAirComponent) {
            this.onAirComponent.refresh();
        }
        
        showNotification('Rundown refreshed with updated durations', 'info');
    }

    // Vider tout le conducteur
    clearAllConductor() {
        if (!confirm('‚ö†Ô∏è √ätes-vous s√ªr de vouloir supprimer TOUS les √©l√©ments du conducteur ?')) {
            return;
        }
        
        // Vider le tableau des segments
        this.conductorManager.clearAll();
        
        // Rafra√Æchir ON AIR si actif
        if (this.onAirInitialized && this.onAirComponent) {
            this.onAirComponent.refresh();
        }
        
        // Sauvegarder
        this.autoSave();
        
        showNotification('‚úÖ Conducteur vid√©', 'success');
    }

    loadTemplate(templateName) {
        showNotification('Les templates ont √©t√© retir√©s de cette version', 'info');
    }

    saveTemplate() {
        showNotification('Les templates ont √©t√© retir√©s de cette version', 'info');
        return;
        const options = [
            'Save template as:',
            '',
            'Day template:',
            '- monday',
            '- tuesday',
            '- wednesday',
            '- thursday',
            '- friday',
            '- saturday',
            '- sunday',
            '',
            'Or enter a custom name'
        ].join('\n');
        
        const templateName = prompt(options);
        if (!templateName) return;
        
        const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
        const dayIndex = days.indexOf(templateName.toLowerCase());
        
        if (dayIndex !== -1) {
            // Save as day template
            this.templateManager.saveAsTemplate(
                `${templateName.charAt(0).toUpperCase() + templateName.slice(1)} Template`,
                dayIndex
            );
        } else {
            // Save as generic template
            this.templateManager.saveAsTemplate(templateName, null);
        }
    }

    showTemplateList() {
        const templates = this.templateManager.getAllTemplates();
        if (templates.length === 0) {
            showNotification('No saved templates found', 'info');
            return;
        }
        
        let list = 'Saved templates:\n\n';
        templates.forEach(template => {
            const type = template.dayOfWeek !== null ? 
                `Day: ${this.templateManager.getDayName(template.dayOfWeek)}` : 'Generic';
            list += `- ${template.name} (${type})\n`;
        });
        
        alert(list);
    }

    goLive() {
        this.isLive = true;
        this.showStartTime = new Date();
        
        // Switch to ON AIR tab
        this.switchTab('onair');
        
        showNotification('Show is LIVE! Switched to ON AIR mode.', 'success');
    }
    
    updateShowStartTime() {
        const showStartInput = safeGetElement('show-start-time');
        if (!showStartInput || !showStartInput.value) return;
        
        const [hours, minutes] = showStartInput.value.split(':').map(Number);
        const startTime = new Date();
        startTime.setHours(hours, minutes, 0, 0);
        
        // Si l'heure est d√©j√† pass√©e aujourd'hui, prendre demain
        const now = new Date();
        if (startTime < now) {
            startTime.setDate(startTime.getDate() + 1);
        }
        
        this.scheduledStartTime = startTime;
        
        // Mettre √† jour le conducteur
        this.conductorManager.render();
        
        showNotification(`Show scheduled for ${showStartInput.value}`, 'info');
    }

    // Initialize On Air
    initializeOnAir() {
        if (!this.onAirComponent) {
            this.onAirComponent = new OnAir();
            this.onAirComponent.init({
                conductorManager: this.conductorManager,
                newsManager: this.newsManager,
                animationManager: this.animationManager,
                audioManager: this.audioManager
            });
        }
        this.onAirComponent.refresh();
        this.onAirInitialized = true;
    }

    // Initialize Blocks component
    initializeBlocks() {
        if (!this.blocksComponent) {
            this.blocksComponent = new Blocks();
            this.blocksComponent.init({
                blockManager: this.blockManager,
                newsManager: this.newsManager,
                animationManager: this.animationManager
            });
        }
        // Toujours rafra√Æchir la liste des blocks
        this.blockManager.render();
        this.blocksInitialized = true;
    }

    // Initialize Print
    initializePrint() {
        // Print initialization if needed
        this.printInitialized = true;
    }

    // Initialize Audio Editor
    async initializeAudioEditor() {
        if (!this.audioEditor) {
            this.audioEditor = new AudioEditor();
        }
        await this.audioEditor.init();
        this.audioEditorInitialized = true;
    }

    // Initialize Multitrack Editor
    async initializeMultitrack() {
        if (!this.multitrackEditor) {
            console.log('Lazy loading MultitrackEditor...');
            this.multitrackEditor = new MultitrackEditor();
        }
        if (!this.multitrackEditor.initialized) {
            await this.multitrackEditor.init();
        }
        
        // Add file input handler only once
        const fileInput = document.getElementById('multitrack-file-input');
        if (fileInput && !fileInput.hasAttribute('data-listener-attached')) {
            fileInput.addEventListener('change', async (e) => {
                const files = e.target.files;
                for (let file of files) {
                    await this.multitrackEditor.addToLibrary(file);
                }
                e.target.value = ''; // Reset input
            });
            fileInput.setAttribute('data-listener-attached', 'true');
        }
        
        this.multitrackInitialized = true;
    }

    // Initialize Fridge
    initializeFridge() {
        if (!this.fridgeComponent) {
            this.fridgeComponent = new Fridge();
        }
        if (!this.fridgeComponent.initialized) {
            this.fridgeComponent.init({
                newsManager: this.newsManager,
                animationManager: this.animationManager,
                blockManager: this.blockManager,
                conductorManager: this.conductorManager
            });
        }
        // Notifier le changement d'onglet
        this.fridgeComponent.onTabChange('fridge');
        this.fridgeInitialized = true;
    }
    
    // Initialize Template Builder
    initializeTemplateBuilder() {
        try {
            if (window.timelineBuilder) {
                window.timelineBuilder.render();
            } else if (window.TimelineBuilder) {
                // Si l'instance n'existe pas mais la classe existe, cr√©er l'instance
                window.timelineBuilder = new window.TimelineBuilder();
                window.timelineBuilder.render();
            } else {
                console.error('‚ùå TimelineBuilder not found! Make sure the script is loaded.');
            }
        } catch (error) {
            console.error('‚ùå Template Builder initialization failed:', error);
        }
    }

    // Print methods
    printNews() {
        const item = this.newsManager.getCurrentItem();
        if (!item) {
            showNotification('No news selected', 'error');
            return;
        }
        
        // Cr√©er une fen√™tre d'impression
        const printWindow = window.open('', '_blank', 'width=800,height=600');
        const printDoc = printWindow.document;
        
        // Styles d'impression
        printDoc.write(`
            <!DOCTYPE html>
            <html>
            <head>
                <title>${item.title} - ${new Date().toLocaleDateString('fr-FR')}</title>
                <style>
                    body {
                        font-family: Arial, sans-serif;
                        max-width: 800px;
                        margin: 0 auto;
                        padding: 20px;
                        line-height: 1.6;
                    }
                    h1 {
                        font-size: 24px;
                        margin-bottom: 10px;
                    }
                    .meta {
                        color: #666;
                        margin-bottom: 20px;
                        font-size: 14px;
                    }
                    .content {
                        font-size: 16px;
                        white-space: pre-wrap;
                    }
                    .sounds {
                        margin-top: 20px;
                        padding: 10px;
                        background: #f5f5f5;
                        border-radius: 5px;
                    }
                    .sounds h3 {
                        margin-top: 0;
                        font-size: 18px;
                    }
                    .sound-item {
                        margin: 5px 0;
                        padding: 5px;
                        background: white;
                        border-radius: 3px;
                    }
                    @media print {
                        body { padding: 0; }
                    }
                </style>
            </head>
            <body>
                <h1>${sanitizeHTML(item.title)}</h1>
                <div class="meta">
                    <strong>Cat√©gorie:</strong> ${item.category} | 
                    <strong>Dur√©e:</strong> ${item.duration} | 
                    <strong>Auteur:</strong> ${sanitizeHTML(item.author)} | 
                    <strong>Statut:</strong> ${item.status} | 
                    <strong>Date:</strong> ${new Date().toLocaleDateString('fr-FR')}
                </div>
                <div class="content">${sanitizeHTML(item.content)
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/__(.*?)__/g, '<u>$1</u>')
                    .replace(/\n/g, '<br>')}</div>
        `);
        
        // Ajouter les sons s'il y en a
        if (item.sounds && item.sounds.length > 0) {
            printDoc.write(`
                <div class="sounds">
                    <h3>√âl√©ments sonores (${item.sounds.length})</h3>
            `);
            
            item.sounds.forEach(sound => {
                printDoc.write(`
                    <div class="sound-item">
                        <strong>${sanitizeHTML(sound.name)}</strong> - 
                        ${sound.type} - 
                        ${sound.duration}
                        ${sound.description ? `<br><em>${sanitizeHTML(sound.description)}</em>` : ''}
                    </div>
                `);
            });
            
            printDoc.write('</div>');
        }
        
        // Notes si pr√©sentes
        if (item.notes) {
            printDoc.write(`
                <div style="margin-top: 20px; padding: 10px; border: 1px solid #ddd; border-radius: 5px;">
                    <strong>Notes:</strong><br>
                    ${sanitizeHTML(item.notes).replace(/\n/g, '<br>')}
                </div>
            `);
        }
        
        printDoc.write(`
            </body>
            </html>
        `);
        
        printDoc.close();
        
        // Lancer l'impression apr√®s un court d√©lai
        setTimeout(() => {
            printWindow.print();
        }, 250);
    }
    
    generateConductorTable() {
        // Implementation for conductor table generation
        const container = safeGetElement('conductor-table-container');
        if (!container) return;
        
        const printData = this.conductorManager.generatePrintData();
        // Generate HTML table from printData
        
        showNotification('Conductor table generated', 'success');
    }

    printConductor() {
        this.generateConductorTable();
        setTimeout(() => {
            window.print();
        }, 100);
    }

    exportConductorPDF() {
        this.generateConductorTable();
        setTimeout(() => {
            window.print();
        }, 100);
    }

    exportConductor() {
        // Export conductor data for Action de Grace
        const exportData = this.conductorManager.exportForActionDeGrace();
        
        // Create JSON file
        const dataStr = JSON.stringify(exportData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        
        // Create download link
        const link = document.createElement('a');
        link.href = url;
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
        link.download = `conductor_export_${timestamp}.json`;
        
        // Trigger download
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        // Clean up
        URL.revokeObjectURL(url);
        
        showNotification('Conductor exported for Action de Grace', 'success');
    }



    // Sound file handlers
    async handleSoundFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const soundData = await this.audioManager.handleFileUpload(file);
        if (soundData) {
            safeSetValue('sound-name', file.name.replace(/\.[^/.]+$/, ""));
            safeSetValue('sound-duration', soundData.duration);
            safeGetElement('add-sound-btn').disabled = false;
            
            const waveformEl = safeGetElement('sound-waveform');
            if (waveformEl) {
                waveformEl.style.display = 'block';
                this.audioManager.generateWaveform('waveform');
            }
        }
    }

    async handleAnimationSoundFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const soundData = await this.audioManager.handleFileUpload(file);
        if (soundData) {
            safeSetValue('animation-sound-name', file.name.replace(/\.[^/.]+$/, ""));
            safeSetValue('animation-sound-duration', soundData.duration);
            safeGetElement('add-animation-sound-btn').disabled = false;
            
            const waveformEl = safeGetElement('animation-sound-waveform');
            if (waveformEl) {
                waveformEl.style.display = 'block';
                this.audioManager.generateWaveform('animation-waveform');
            }
        }
    }

    // Add sound
    async addSound() {
        const soundData = await this.audioManager.handleSoundModalSubmit('news');
        if (soundData) {
            await this.newsManager.addSound(soundData);
            this.closeModal('sound-modal');
        }
    }

    async addAnimationSound() {
        const soundData = await this.audioManager.handleSoundModalSubmit('animation');
        if (soundData) {
            await this.animationManager.addSound(soundData);
            this.closeModal('animation-sound-modal');
        }
    }

    // Preview
    preview(type) {
        const manager = type === 'news' ? this.newsManager : this.animationManager;
        const item = manager.getCurrentItem();
        if (!item) return;
        
        // Create preview modal
        const modal = document.createElement('div');
        modal.className = 'modal active';
        modal.innerHTML = this.getPreviewHTML(item, type);
        document.body.appendChild(modal);
    }

    getPreviewHTML(item, type) {
        // Preview implementation
        return `
            <div class="modal-content" style="max-width: 800px;">
                <div class="modal-header">
                    <h3>${type === 'news' ? 'News' : 'Animation'} Preview</h3>
                    <button class="icon-btn" onclick="this.closest('.modal').remove()">‚úï</button>
                </div>
                <div class="modal-body">
                    <h2>${sanitizeHTML(item.title)}</h2>
                    <p>Duration: ${item.duration}</p>
                    <div style="margin-top: 1rem;">
                        ${item.content.replace(/\n/g, '<br>')}
                    </div>
                </div>
            </div>
        `;
    }
    // Cross-user library methods
    async initializeUserSelectors() {
        if (!this.crossUserManager) return;
        
        // Cr√©er les s√©lecteurs pour News et Animations
        const newsSelectorHTML = await this.crossUserManager.createUserSelector('news');
        const animationSelectorHTML = await this.crossUserManager.createUserSelector('animation');
        
        const newsSelector = document.getElementById('news-user-selector');
        if (newsSelector) {
            newsSelector.innerHTML = newsSelectorHTML;
        }
        
        const animationSelector = document.getElementById('animation-user-selector');
        if (animationSelector) {
            animationSelector.innerHTML = animationSelectorHTML;
        }
    }
    
    async switchUserLibrary(userId) {
        if (!this.crossUserManager) return;
        
        // Si vide, afficher ses propres √©l√©ments
        if (!userId) {
            this.newsManager.render();
            this.currentViewingUser = null;
            document.querySelectorAll('.import-indicator').forEach(el => el.remove());
            
            // Nettoyer le mode lecture seule si actif
            this.cleanupReadOnlyMode('news');
            
            // R√©attacher les event listeners pour les news locales
            setTimeout(() => {
                document.querySelectorAll('.news-item').forEach(item => {
                    if (!item.dataset.externalUser) {
                        const newsId = item.dataset.newsId;
                        if (newsId) {
                            item.style.cursor = 'pointer';
                            // Utiliser app directement pour √©viter les probl√®mes de contexte
                            item.onclick = () => app.newsManager.load(parseInt(newsId));
                        }
                    }
                });
            }, 100);
            return;
        }
        
        // Charger et afficher les news de l'autre utilisateur
        this.currentViewingUser = userId;
        const userNews = await this.crossUserManager.getUserNews(userId);
        
        // Afficher dans la liste avec un indicateur d'import
        const container = document.getElementById('news-list');
        if (container) {
            container.innerHTML = userNews.length > 0 ? userNews.map(news => {
                const statusIcon = Constants.STATUS_ICONS[news.status] || Constants.STATUS_ICONS.draft;
                return `
                    <div class="news-item external-item" data-news-id="${news.id}" 
                         data-external-user="${userId}"
                         onclick="app.viewExternalNews('${news.id}', '${userId}')"
                         style="cursor: pointer;">
                        <div class="import-indicator">
                            <span style="color: #00ff9f; font-size: 0.75rem;">üë• ${userId}</span>
                            <button class="btn btn-small" onclick="event.stopPropagation(); app.importExternalNews('${news.id}', '${userId}')" 
                                    style="padding: 0.2rem 0.5rem; font-size: 0.7rem;">
                                üì• Importer
                            </button>
                        </div>
                        <div class="flex justify-between items-center">
                            <h3>${sanitizeHTML(news.title)}</h3>
                            <span title="${news.status || 'draft'}">${statusIcon}</span>
                        </div>
                        <div class="meta">
                            ${news.category} ‚Ä¢ ${news.duration} ‚Ä¢ ${sanitizeHTML(news.author)}
                        </div>
                    </div>
                `;
            }).join('') : `<p style="color: #999; text-align: center; padding: 2rem;">Aucune news trouv√©e chez ${userId}</p>`;
        }
    }
    
    async importExternalNews(newsId, fromUser) {
        if (!this.crossUserManager) return;
        
        console.log(`üîç Tentative d'import: newsId="${newsId}" (type: ${typeof newsId}), fromUser="${fromUser}"`);
        
        // R√©cup√©rer la news originale
        const userNews = await this.crossUserManager.getUserNews(fromUser);
        console.log(`üìö News disponibles chez ${fromUser}:`, userNews.map(n => ({ id: n.id, type: typeof n.id, title: n.title })));
        
        // Essayer de trouver avec conversion de type si n√©cessaire
        const originalNews = userNews.find(n => 
            n.id == newsId || // Comparaison souple
            n.id === newsId || // Comparaison stricte
            n.id === Number(newsId) || // Si l'ID est un nombre
            n.id === String(newsId) // Si l'ID est une cha√Æne
        );
        
        if (!originalNews) {
            console.error(`‚ùå News introuvable avec ID: ${newsId}`);
            showNotification('News introuvable', 'error');
            return;
        }
        
        console.log(`‚úÖ News trouv√©e:`, originalNews.title);
        
        // Importer
        const imported = this.crossUserManager.importNews(originalNews, fromUser);
        
        // Ajouter √† sa propre base
        this.newsManager.getDatabase().push(imported);
        this.newsManager.setDatabase(this.newsManager.getDatabase());
        
        // Revenir √† sa propre biblioth√®que
        document.getElementById('library-user-selector-news').value = '';
        this.switchUserLibrary('');
        
        // S√©lectionner la news import√©e
        this.newsManager.load(imported.id);
        
        // Sauvegarder
        this.autoSave();
    }
    
    cleanupReadOnlyMode(type) {
        // R√©activer tous les champs
        const fields = [
            `${type}-title`,
            `${type}-category`,
            `${type}-author`, 
            `${type}-editor-content`,
            `${type}-notes`
        ];
        
        fields.forEach(fieldId => {
            const element = document.getElementById(fieldId);
            if (element) {
                element.disabled = false;
                element.style.opacity = '1';
                element.style.cursor = 'text';
            }
        });
        
        // R√©afficher les boutons
        const saveBtn = document.getElementById(`${type}-save-btn`);
        const deleteBtn = document.getElementById(`${type}-delete-btn`);
        if (saveBtn) saveBtn.style.display = '';
        if (deleteBtn) deleteBtn.style.display = '';
        
        // Retirer le bouton d'import si pr√©sent
        const importBtn = document.getElementById('import-from-view-btn');
        if (importBtn) importBtn.remove();
        
        // R√©initialiser le titre de l'√©diteur
        const editorHeader = document.querySelector(`#${type}-editor .editor-header h2`);
        if (editorHeader) {
            editorHeader.innerHTML = type === 'news' ? '√âditeur de News' : '√âditeur d\'Animation';
        }
    }
    
    async viewExternalNews(newsId, fromUser) {
        if (!this.crossUserManager) return;
        
        // R√©cup√©rer la news
        const userNews = await this.crossUserManager.getUserNews(fromUser);
        const news = userNews.find(n => 
            n.id == newsId || 
            n.id === Number(newsId) || 
            n.id === String(newsId)
        );
        
        if (!news) {
            showNotification('News introuvable', 'error');
            return;
        }
        
        // Afficher la news en mode lecture seule
        this.newsManager.showEditor();
        
        // Remplir les champs mais d√©sactiver l'√©dition
        const fieldsToFill = [
            { id: 'news-title', value: news.title },
            { id: 'news-category', value: news.category },
            { id: 'news-author', value: news.author },
            { id: 'news-editor-content', value: news.content },
            { id: 'news-notes', value: news.notes || '' }
        ];
        
        fieldsToFill.forEach(field => {
            const element = document.getElementById(field.id);
            if (element) {
                element.value = field.value || '';
                element.disabled = true;
                element.style.opacity = '0.7';
                element.style.cursor = 'not-allowed';
            }
        });
        
        // Masquer les boutons de sauvegarde et suppression
        const saveBtn = document.getElementById('news-save-btn');
        const deleteBtn = document.getElementById('news-delete-btn');
        if (saveBtn) saveBtn.style.display = 'none';
        if (deleteBtn) deleteBtn.style.display = 'none';
        
        // Ajouter un indicateur de lecture seule
        const editorHeader = document.querySelector('#news-editor .editor-header h2');
        if (editorHeader) {
            editorHeader.innerHTML = `üë• ${fromUser} - ${news.title} <span style="color: #ff9f00; font-size: 0.8rem;">(Lecture seule)</span>`;
        }
        
        // Ajouter un bouton pour importer directement depuis la vue
        const editorActions = document.querySelector('#news-editor .editor-actions');
        if (editorActions && !document.getElementById('import-from-view-btn')) {
            const importBtn = document.createElement('button');
            importBtn.id = 'import-from-view-btn';
            importBtn.className = 'btn btn-primary';
            importBtn.innerHTML = 'üì• Importer cette news';
            importBtn.onclick = () => {
                this.importExternalNews(newsId, fromUser);
                // Fermer la vue lecture seule
                this.newsManager.hideEditor();
            };
            editorActions.appendChild(importBtn);
        }
    }
    
    async switchUserLibraryAnimation(userId) {
        if (!this.crossUserManager) return;
        
        // Si vide, afficher ses propres √©l√©ments
        if (!userId) {
            this.animationManager.render();
            this.currentViewingUserAnimation = null;
            
            // R√©attacher les event listeners pour les animations locales
            setTimeout(() => {
                document.querySelectorAll('.animation-item').forEach(item => {
                    if (!item.dataset.externalUser) {
                        const animationId = item.dataset.animationId;
                        if (animationId) {
                            item.style.cursor = 'pointer';
                            // Utiliser app directement pour √©viter les probl√®mes de contexte
                            item.onclick = () => app.animationManager.load(parseInt(animationId));
                        }
                    }
                });
            }, 100);
            return;
        }
        
        // Charger et afficher les animations de l'autre utilisateur
        this.currentViewingUserAnimation = userId;
        const userAnimations = await this.crossUserManager.getUserAnimations(userId);
        
        // Afficher dans la liste avec un indicateur d'import
        const container = document.getElementById('animation-list');
        if (container) {
            container.innerHTML = userAnimations.length > 0 ? userAnimations.map(animation => {
                const statusIcon = Constants.STATUS_ICONS[animation.status] || Constants.STATUS_ICONS.draft;
                return `
                    <div class="animation-item external-item" data-animation-id="${animation.id}" 
                         data-external-user="${userId}">
                        <div class="import-indicator">
                            <span style="color: #00ff9f; font-size: 0.75rem;">üë• ${userId}</span>
                            <button class="btn btn-small" onclick="app.importExternalAnimation('${animation.id}', '${userId}')" 
                                    style="padding: 0.2rem 0.5rem; font-size: 0.7rem;">
                                üì• Importer
                            </button>
                        </div>
                        <div class="flex justify-between items-center">
                            <h3>${sanitizeHTML(animation.title)}</h3>
                            <span title="${animation.status || 'draft'}">${statusIcon}</span>
                        </div>
                        <div class="meta">
                            ${animation.duration} ‚Ä¢ ${sanitizeHTML(animation.author)}
                        </div>
                    </div>
                `;
            }).join('') : `<p style="color: #999; text-align: center; padding: 2rem;">Aucune animation trouv√©e chez ${userId}</p>`;
        }
    }
    
    async importExternalAnimation(animationId, fromUser) {
        if (!this.crossUserManager) return;
        
        console.log(`üîç Tentative d'import animation: animationId="${animationId}" (type: ${typeof animationId}), fromUser="${fromUser}"`);
        
        // R√©cup√©rer l'animation originale
        const userAnimations = await this.crossUserManager.getUserAnimations(fromUser);
        console.log(`üìö Animations disponibles chez ${fromUser}:`, userAnimations.map(a => ({ id: a.id, type: typeof a.id, title: a.title })));
        
        // Essayer de trouver avec conversion de type si n√©cessaire
        const originalAnimation = userAnimations.find(a => 
            a.id == animationId || // Comparaison souple
            a.id === animationId || // Comparaison stricte
            a.id === Number(animationId) || // Si l'ID est un nombre
            a.id === String(animationId) // Si l'ID est une cha√Æne
        );
        
        if (!originalAnimation) {
            console.error(`‚ùå Animation introuvable avec ID: ${animationId}`);
            showNotification('Animation introuvable', 'error');
            return;
        }
        
        console.log(`‚úÖ Animation trouv√©e:`, originalAnimation.title);
        
        // Importer
        const imported = this.crossUserManager.importAnimation(originalAnimation, fromUser);
        
        // Ajouter √† sa propre base
        this.animationManager.getDatabase().push(imported);
        this.animationManager.setDatabase(this.animationManager.getDatabase());
        
        // Revenir √† sa propre biblioth√®que
        document.getElementById('library-user-selector-animation').value = '';
        this.switchUserLibraryAnimation('');
        
        // S√©lectionner l'animation import√©e
        this.animationManager.load(imported.id);
        
        // Sauvegarder
        this.autoSave();
    }
    
    // Multi-select block functions
    toggleBlockSelector(prefix) {
        const dropdown = document.getElementById(`${prefix}block-selector-list`);
        if (dropdown) {
            const isVisible = dropdown.style.display !== 'none';
            dropdown.style.display = isVisible ? 'none' : 'block';
            
            // Close dropdown when clicking outside
            if (!isVisible) {
                const closeDropdown = (e) => {
                    if (!e.target.closest('.block-selector-dropdown')) {
                        dropdown.style.display = 'none';
                        document.removeEventListener('click', closeDropdown);
                    }
                };
                setTimeout(() => document.addEventListener('click', closeDropdown), 100);
            }
        }
    }
    
    updateSelectedBlocks(prefix) {
        const checkboxes = document.querySelectorAll(`#${prefix}block-selector-list input[type="checkbox"]:checked`);
        const textElement = document.getElementById(`${prefix}selected-blocks-text`);
        
        // V√©rifier que l'√©l√©ment existe avant de le modifier
        if (!textElement) {
            console.warn(`Element ${prefix}selected-blocks-text not found`);
            return;
        }
        
        if (checkboxes.length === 0) {
            textElement.textContent = 'üìÅ Journaux';
        } else if (checkboxes.length === 1) {
            const blockId = checkboxes[0].value;
            const block = this.blockManager.getBlockById(blockId);
            if (block) {
                textElement.textContent = `üìÅ ${block.title}`;
            }
        } else {
            textElement.textContent = `üìÅ ${checkboxes.length} journaux`;
        }
        
        // Update the current item's assigned blocks
        const manager = prefix.includes('animation') ? this.animationManager : this.newsManager;
        if (manager && manager.currentItemId) {
            const assignedBlocks = Array.from(checkboxes).map(cb => cb.value);
            manager.updateAssignedBlocks(assignedBlocks);
        }
    }

    // Export/Import data
    async exportData() {
        await this.storage.exportData();
    }

    async importData() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        
        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (file) {
                try {
                    await this.storage.importData(file);
                    await this.loadData();
                    this.initializeUI();
                    showNotification('Data imported successfully!', 'success');
                } catch (error) {
                    console.error('Import error:', error);
                    showNotification('Import failed. Please check the file format.', 'error');
                }
            }
        };
        
        input.click();
    }

    async clearAllData() {
        if (confirm('Reset all data? This cannot be undone.')) {
            await this.storage.clearAll();
            this.newsDatabase = [];
            this.animationDatabase = [];
            this.blocksDatabase = [];
            this.conductorSegments = [];
            this.newsManager.setDatabase([]);
            this.animationManager.setDatabase([]);
            this.blockManager.setBlocks([]);
            this.conductorManager.setSegments([]);
            this.initializeUI();
            showNotification('All data cleared', 'warning');
        }
    }

    // Block modal
    openAddItemToBlockModal() {
        const modal = safeGetElement('block-assign-modal');
        if (modal) {
            modal.classList.add('active');
            this.blockManager.updateAssignModalContent();
        }
    }


    // Block context menu
    showBlockContextMenu(event, blockId) {
        event.preventDefault();
        
        // Cr√©er un menu contextuel
        const existingMenu = document.querySelector('.context-menu');
        if (existingMenu) existingMenu.remove();
        
        const menu = document.createElement('div');
        menu.className = 'context-menu';
        menu.style.cssText = `
            position: fixed;
            left: ${event.clientX}px;
            top: ${event.clientY}px;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 0.5rem 0;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        `;
        
        const menuItems = [
            { icon: 'üì∞', text: 'Add News', type: 'news' },
            { icon: 'üéôÔ∏è', text: 'Add Animation', type: 'animation' },
            { icon: 'üéµ', text: 'Add Jingle', type: 'jingle' },
            { icon: 'üì∫', text: 'Add Commercial', type: 'pub' },
            { icon: '‚òÅÔ∏è', text: 'Add Weather', type: 'meteo' },
            { icon: 'üìπ', text: 'Add Package', type: 'package' },
            { icon: 'üî¥', text: 'Add Live', type: 'live' },
            { icon: '‚úèÔ∏è', text: 'Add Custom', type: 'custom' }
        ];
        
        menuItems.forEach(item => {
            const menuItem = document.createElement('div');
            menuItem.style.cssText = `
                padding: 0.5rem 1rem;
                cursor: pointer;
                color: #ccc;
                transition: all 0.2s;
            `;
            menuItem.innerHTML = `${item.icon} ${item.text}`;
            menuItem.onmouseover = () => {
                menuItem.style.backgroundColor = '#444';
                menuItem.style.color = '#fff';
            };
            menuItem.onmouseout = () => {
                menuItem.style.backgroundColor = 'transparent';
                menuItem.style.color = '#ccc';
            };
            menuItem.onclick = () => {
                menu.remove();
                // Set parent block in modal
                this.addSegmentToBlock(blockId, item.type);
            };
            menu.appendChild(menuItem);
        });
        
        document.body.appendChild(menu);
        
        // Remove menu on click outside
        setTimeout(() => {
            document.addEventListener('click', function removeMenu() {
                menu.remove();
                document.removeEventListener('click', removeMenu);
            });
        }, 100);
    }
    
    addSegmentToBlock(blockId, type) {
        // Ouvrir le modal avec le parent pr√©-s√©lectionn√©
        this.addSegmentModal();
        
        // Attendre que le modal soit rendu
        setTimeout(() => {
            safeSetValue('segment-type', type);
            this.updateSegmentForm();
            
            // Attendre que le formulaire soit mis √† jour
            setTimeout(() => {
                const parentSelect = safeGetElement('segment-parent-id');
                if (parentSelect) {
                    parentSelect.value = blockId.toString();
                }
            }, 50);
        }, 50);
    }

    // Cleanup
    // Update block selector color based on selection
    updateBlockSelectorColor(prefix) {
        const selector = safeGetElement(`${prefix}assigned-block`);
        if (!selector) return;
        
        const selectedOption = selector.options[selector.selectedIndex];
        if (selectedOption && selectedOption.dataset.color) {
            selector.style.borderLeft = `4px solid ${selectedOption.dataset.color}`;
            selector.style.backgroundColor = `${selectedOption.dataset.color}20`;
        } else {
            selector.style.borderLeft = '1px solid #444';
            selector.style.backgroundColor = '#1a1a1a';
        }
    }
    
    // Sidebar toggle for mobile
    toggleSidebar() {
        const sidebar = document.getElementById('sidebar');
        if (sidebar) {
            sidebar.classList.toggle('expanded');
        }
    }
    
    // Fullscreen toggle
    toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
        } else {
            document.exitFullscreen();
        }
    }
    
    // Template Management Functions
    showTemplateMenu() {
        this.openModal('template-modal');
        this.loadTemplateList();
        this.updateDailyStatus();
    }
    
    loadTemplateList() {
        const container = document.getElementById('template-list-container');
        if (!container) return;
        
        const templates = this.conductorTemplateManager.templates;
        container.innerHTML = '';
        
        if (templates.length === 0) {
            container.innerHTML = '<p style="text-align: center; color: #999;">Aucun template disponible</p>';
            return;
        }
        
        templates.forEach(template => {
            const item = document.createElement('div');
            item.className = 'template-item';
            item.dataset.templateId = template.id;
            item.innerHTML = `
                <div class="template-item-info">
                    <div class="template-item-name">${template.name}</div>
                    <div class="template-item-description">${template.description}</div>
                </div>
                <div class="template-item-actions">
                    <button class="btn btn-sm" onclick="app.previewTemplate('${template.id}')">Aper√ßu</button>
                </div>
            `;
            item.onclick = () => this.selectTemplate(template.id);
            container.appendChild(item);
        });
        
        // Set today's date as default
        const dateInput = document.getElementById('template-target-date');
        if (dateInput) {
            dateInput.value = new Date().toISOString().split('T')[0];
        }
    }
    
    selectTemplate(templateId) {
        // Remove previous selection
        document.querySelectorAll('.template-item').forEach(item => {
            item.classList.remove('selected');
        });
        
        // Add selection to clicked item
        const item = document.querySelector(`[data-template-id="${templateId}"]`);
        if (item) {
            item.classList.add('selected');
        }
        
        // Store selected template
        this.selectedTemplateId = templateId;
        
        // Show preview
        this.previewTemplate(templateId);
    }
    
    previewTemplate(templateId) {
        const template = this.conductorTemplateManager.templates.find(t => t.id === templateId);
        if (!template) return;
        
        const preview = document.getElementById('template-preview');
        if (!preview) return;
        
        let html = '<h5>Aper√ßu du template :</h5>';
        template.segments.forEach(segment => {
            const typeClass = segment.contentType === 'block-container' ? 'block-container' : segment.contentType;
            const typeLabel = {
                'daily': 'üìÖ Quotidien',
                'recurring': 'üîÑ R√©current (r√©utilis√©)',
                'recurring-duplicate': 'üìù R√©current (dupliqu√©)',
                'permanent': 'üìå Permanent',
                'dynamic': '‚ö° Dynamique',
                'block-container': 'üì¶ Bloc vide'
            }[segment.contentType] || segment.contentType;
            
            let description = '';
            if (segment.contentType === 'block-container' && segment.contentFilter) {
                description = `<br><small style="color: ${segment.contentFilter.color}">
                    ${segment.contentFilter.description || '√Ä remplir avec les sujets du jour'}
                </small>`;
            }
            
            html += `
                <div class="preview-segment ${typeClass}">
                    <strong>${segment.title}</strong>
                    <span class="segment-type">${typeLabel}</span>
                    <br>
                    <small>Dur√©e: ${segment.duration} | Position: ${segment.position}</small>
                    ${description}
                </div>
            `;
        });
        
        preview.innerHTML = html;
    }
    
    async applySelectedTemplate() {
        if (!this.selectedTemplateId) {
            showNotification('Veuillez s√©lectionner un template', 'warning');
            return;
        }
        
        const dateInput = document.getElementById('template-target-date');
        const targetDate = dateInput ? new Date(dateInput.value) : new Date();
        
        try {
            showNotification('Application du template en cours...', 'info');
            
            // Apply the template
            const conductor = await this.conductorTemplateManager.applyTemplate(this.selectedTemplateId, targetDate);
            
            // Count different types of segments
            let existingCount = 0;
            let newCount = 0;
            let emptyBlocks = 0;
            
            conductor.segments.forEach(segment => {
                if (segment.status === 'empty-block') {
                    emptyBlocks++;
                } else if (segment.content) {
                    if (segment.content.isDuplicate) {
                        newCount++;
                    } else {
                        existingCount++;
                    }
                }
            });
            
            // Add segments to conductor manager
            conductor.segments.forEach(segment => {
                this.conductorManager.addSegment(segment);
            });
            
            // Refresh the conductor view
            this.refreshRundown();
            
            // Detailed notification
            let message = `Template appliqu√© : ${conductor.name}`;
            if (existingCount > 0) message += `\n‚úÖ ${existingCount} fiches existantes trouv√©es`;
            if (newCount > 0) message += `\nüìù ${newCount} nouvelles fiches cr√©√©es`;
            if (emptyBlocks > 0) message += `\nüì¶ ${emptyBlocks} blocs vides √† remplir`;
            message += `\nüìä Progression : ${conductor.completion}%`;
            
            showNotification(message, 'success');
            
            // Close modal
            this.closeModal('template-modal');
            
        } catch (error) {
            console.error('Error applying template:', error);
            showNotification('Erreur lors de l\'application du template', 'error');
        }
    }
    
    switchTemplateTab(tab) {
        // Update tab buttons
        document.querySelectorAll('.template-tab').forEach(btn => {
            btn.classList.remove('active');
        });
        event.target.classList.add('active');
        
        // Hide all tab contents
        document.querySelectorAll('.template-tab-content').forEach(content => {
            content.style.display = 'none';
        });
        
        // Show selected tab
        const tabContent = document.getElementById(`template-${tab}-tab`);
        if (tabContent) {
            tabContent.style.display = 'block';
        }
        
        // Update footer button
        const applyBtn = document.getElementById('template-apply-btn');
        if (applyBtn) {
            if (tab === 'apply') {
                applyBtn.style.display = 'block';
            } else {
                applyBtn.style.display = 'none';
            }
        }
        
        // Load content for specific tabs
        if (tab === 'manage') {
            this.loadTemplateManager();
        }
    }
    
    createTemplateFromCurrent() {
        const nameInput = document.getElementById('template-name');
        const descInput = document.getElementById('template-description');
        
        if (!nameInput || !nameInput.value) {
            showNotification('Veuillez entrer un nom pour le template', 'warning');
            return;
        }
        
        const currentConductor = {
            name: 'Current Conductor',
            segments: this.conductorManager.getSegments()
        };
        
        if (currentConductor.segments.length === 0) {
            showNotification('Le conducteur actuel est vide', 'warning');
            return;
        }
        
        const template = this.conductorTemplateManager.createTemplateFromConductor(
            currentConductor,
            nameInput.value
        );
        
        if (descInput && descInput.value) {
            template.description = descInput.value;
        }
        
        showNotification(`Template "${template.name}" cr√©√© avec succ√®s`, 'success');
        
        // Clear inputs
        nameInput.value = '';
        if (descInput) descInput.value = '';
        
        // Switch to apply tab
        this.switchTemplateTab('apply');
        this.loadTemplateList();
    }
    
    loadTemplateManager() {
        const container = document.getElementById('template-manage-list');
        if (!container) return;
        
        const templates = this.conductorTemplateManager.templates;
        container.innerHTML = '';
        
        if (templates.length === 0) {
            container.innerHTML = '<p style="text-align: center; color: #999;">Aucun template √† g√©rer</p>';
            return;
        }
        
        templates.forEach(template => {
            const item = document.createElement('div');
            item.className = 'template-manage-item';
            item.innerHTML = `
                <div class="template-manage-info">
                    <strong>${template.name}</strong><br>
                    <small>${template.description}</small><br>
                    <small>${template.segments.length} segments</small>
                </div>
                <div class="template-manage-actions">
                    <button class="btn btn-sm" onclick="app.editTemplate('${template.id}')">Modifier</button>
                    <button class="btn btn-sm btn-template danger" onclick="app.deleteTemplate('${template.id}')">Supprimer</button>
                </div>
            `;
            container.appendChild(item);
        });
    }
    
    deleteTemplate(templateId) {
        if (!confirm('√ätes-vous s√ªr de vouloir supprimer ce template ?')) return;
        
        const index = this.conductorTemplateManager.templates.findIndex(t => t.id === templateId);
        if (index !== -1) {
            this.conductorTemplateManager.templates.splice(index, 1);
            this.conductorTemplateManager.saveTemplates();
            showNotification('Template supprim√©', 'success');
            this.loadTemplateManager();
        }
    }
    
    async updateDailyStatus(date = new Date()) {
        const status = await this.conductorTemplateManager.getDailyStatus(date);
        
        // Update status display
        const dateEl = document.getElementById('status-date');
        const readyEl = document.getElementById('status-ready');
        const progressEl = document.getElementById('status-progress');
        const missingEl = document.getElementById('status-missing');
        
        if (dateEl) dateEl.textContent = date.toLocaleDateString('fr-FR');
        if (readyEl) readyEl.textContent = `${status.readySegments}/${status.totalSegments}`;
        if (progressEl) progressEl.style.width = `${status.completion}%`;
        if (missingEl) {
            if (status.missingSegments.length > 0) {
                missingEl.innerHTML = status.missingSegments.join('<br>');
            } else {
                missingEl.textContent = 'Aucun';
            }
        }
    }
    
    // ===== CONDUCTOR STORAGE METHODS =====
    
    async refreshConductorsList() {
        const conductors = await this.conductorStorage.loadConductorsList();
        const select = document.getElementById('conductor-select');
        if (!select) return;
        
        // Clear existing options
        select.innerHTML = '<option value="">-- S√©lectionner un conducteur --</option>';
        
        // Add conductors
        conductors.forEach(conductor => {
            const option = document.createElement('option');
            option.value = conductor.id;
            option.textContent = conductor.name;
            if (conductor.type === 'shared') {
                option.textContent += ' (partag√©)';
            }
            select.appendChild(option);
        });
        
        // Select current conductor if any
        if (this.conductorStorage.currentConductorId) {
            select.value = this.conductorStorage.currentConductorId;
        }
    }
    
    async switchConductor(conductorId) {
        if (!conductorId) return;
        
        try {
            // Load the conductor
            const conductor = await this.conductorStorage.loadConductor(conductorId);
            if (!conductor) {
                showNotification('Impossible de charger le conducteur', 'error');
                return;
            }
            
            // Update conductor segments
            this.conductorSegments = conductor.segments || [];
            
            // Update UI
            await this.conductorManager.loadSegments(this.conductorSegments);
            this.updateConductorInfo(conductor);
            
            showNotification(`Conducteur "${conductor.name}" charg√©`, 'success');
        } catch (error) {
            console.error('Error switching conductor:', error);
            showNotification('Erreur lors du changement de conducteur', 'error');
        }
    }
    
    updateConductorInfo(conductor) {
        const ownerEl = document.getElementById('conductor-owner');
        const statusEl = document.getElementById('conductor-status');
        
        if (ownerEl) {
            ownerEl.textContent = `Propri√©taire: ${conductor.owner || 'Inconnu'}`;
        }
        
        if (statusEl) {
            const lastModified = new Date(conductor.lastModified);
            statusEl.textContent = `Modifi√©: ${lastModified.toLocaleString('fr-FR')}`;
        }
    }
    
    showNewConductorModal() {
        document.getElementById('new-conductor-modal').classList.add('active');
    }
    
    async createNewConductor() {
        const nameInput = document.getElementById('new-conductor-name');
        const templateSelect = document.getElementById('new-conductor-template');
        const publicCheckbox = document.getElementById('new-conductor-public');
        
        const name = nameInput.value.trim();
        if (!name) {
            showNotification('Veuillez entrer un nom pour le conducteur', 'warning');
            return;
        }
        
        try {
            const result = await this.conductorStorage.createConductor(
                name,
                templateSelect.value || null,
                publicCheckbox.checked
            );
            
            if (result.success) {
                // Refresh the list
                await this.refreshConductorsList();
                
                // Load the new conductor
                await this.switchConductor(result.conductorId);
                
                // Close modal
                this.closeModal('new-conductor-modal');
                
                // Clear form
                nameInput.value = '';
                templateSelect.value = '';
                publicCheckbox.checked = false;
                
                showNotification(`Conducteur "${name}" cr√©√© avec succ√®s`, 'success');
            } else {
                showNotification('Erreur lors de la cr√©ation du conducteur', 'error');
            }
        } catch (error) {
            console.error('Error creating conductor:', error);
            showNotification('Erreur lors de la cr√©ation du conducteur', 'error');
        }
    }
    
    async manageConductors() {
        const modal = document.getElementById('manage-conductors-modal');
        const listContainer = document.getElementById('conductors-list');
        
        // Load conductors list
        const conductors = await this.conductorStorage.loadConductorsList();
        
        if (conductors.length === 0) {
            listContainer.innerHTML = `
                <div class="conductors-empty">
                    <h4>Aucun conducteur trouv√©</h4>
                    <p>Cr√©ez votre premier conducteur pour commencer</p>
                </div>
            `;
        } else {
            listContainer.innerHTML = conductors.map(conductor => `
                <div class="conductor-item" data-id="${conductor.id}">
                    <div class="conductor-item-info">
                        <div class="conductor-item-name">
                            ${conductor.name}
                            <span class="conductor-badge ${conductor.type}">${conductor.type === 'shared' ? 'Partag√©' : 'Personnel'}</span>
                        </div>
                        <div class="conductor-item-meta">
                            Propri√©taire: ${conductor.owner || 'Inconnu'} | 
                            Modifi√©: ${new Date(conductor.lastModified).toLocaleDateString('fr-FR')}
                        </div>
                    </div>
                    <div class="conductor-item-actions">
                        <button class="btn-load" onclick="app.loadConductorFromManager('${conductor.id}')">Charger</button>
                        ${conductor.type === 'personal' ? 
                            `<button class="btn-share" onclick="app.shareConductor('${conductor.id}')">Partager</button>` : ''
                        }
                        <button class="btn-duplicate" onclick="app.duplicateConductor('${conductor.id}')">Dupliquer</button>
                        ${conductor.type === 'personal' || conductor.owner === this.storage.userId ? 
                            `<button class="btn-delete" onclick="app.deleteConductor('${conductor.id}')">Supprimer</button>` : ''
                        }
                    </div>
                </div>
            `).join('');
        }
        
        modal.classList.add('active');
    }
    
    async loadConductorFromManager(conductorId) {
        await this.switchConductor(conductorId);
        this.closeModal('manage-conductors-modal');
        
        // Update selector
        document.getElementById('conductor-select').value = conductorId;
    }
    
    async shareConductor(conductorId) {
        try {
            const result = await this.conductorStorage.shareConductor(conductorId);
            if (result.success) {
                showNotification('Conducteur partag√© avec succ√®s', 'success');
                await this.manageConductors(); // Refresh list
            } else {
                showNotification('Erreur lors du partage du conducteur', 'error');
            }
        } catch (error) {
            console.error('Error sharing conductor:', error);
            showNotification('Erreur lors du partage du conducteur', 'error');
        }
    }
    
    async duplicateConductor(conductorId) {
        const newName = prompt('Nom du nouveau conducteur:');
        if (!newName) return;
        
        try {
            const result = await this.conductorStorage.duplicateConductor(conductorId, newName);
            if (result.success) {
                showNotification(`Conducteur dupliqu√©: "${newName}"`, 'success');
                await this.manageConductors(); // Refresh list
            } else {
                showNotification('Erreur lors de la duplication', 'error');
            }
        } catch (error) {
            console.error('Error duplicating conductor:', error);
            showNotification('Erreur lors de la duplication', 'error');
        }
    }
    
    async deleteConductor(conductorId) {
        if (!confirm('√ätes-vous s√ªr de vouloir supprimer ce conducteur ?')) return;
        
        try {
            const result = await this.conductorStorage.deleteConductor(conductorId);
            if (result.success) {
                showNotification('Conducteur supprim√©', 'success');
                await this.manageConductors(); // Refresh list
                
                // If it was the current conductor, clear selection
                if (this.conductorStorage.currentConductorId === conductorId) {
                    this.conductorStorage.currentConductorId = null;
                    document.getElementById('conductor-select').value = '';
                    this.conductorSegments = [];
                    await this.conductorManager.loadSegments([]);
                }
            } else {
                showNotification('Erreur lors de la suppression', 'error');
            }
        } catch (error) {
            console.error('Error deleting conductor:', error);
            showNotification('Erreur lors de la suppression', 'error');
        }
    }
    
    // Save current conductor segments
    async saveConductorSegments() {
        if (!this.conductorStorage.currentConductorId) {
            console.log('No conductor selected, cannot save');
            return;
        }
        
        try {
            const result = await this.conductorStorage.saveConductor(
                this.conductorStorage.currentConductorId,
                this.conductorSegments
            );
            
            if (result.success) {
                console.log('‚úÖ Conductor segments saved');
            } else {
                console.error('Failed to save conductor segments');
            }
        } catch (error) {
            console.error('Error saving conductor segments:', error);
        }
    }
    
    cleanup() {
        // Save before exit
        this.save();
        
        // Clear intervals
        if (this.clockInterval) clearInterval(this.clockInterval);
        if (this.autoSaveInterval) clearInterval(this.autoSaveInterval);
        if (this.autoBackupInterval) clearInterval(this.autoBackupInterval);
    }
}

// Initialize application
document.addEventListener('DOMContentLoaded', async () => {
    console.time('App initialization');
    window.app = new SaintEspritApp();
    await window.app.init();
    console.timeEnd('App initialization');
});