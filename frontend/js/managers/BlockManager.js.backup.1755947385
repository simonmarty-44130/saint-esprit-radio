// Block Manager - g√®re les blocs de contenu
class BlockManager {
    constructor() {
        this.blocks = [];
        this.currentBlockId = null;
        this.listeners = new Map();
        
        // Cache for block calculations
        this.durationCache = new Map();
    }

    // Event system
    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event).push(callback);
    }

    emit(event, data) {
        const callbacks = this.listeners.get(event) || [];
        callbacks.forEach(callback => callback(data));
    }

    // Block operations
    setBlocks(blocks) {
        // Migrer les anciens blocks pour utiliser les titres automatiques
        this.blocks = blocks.map(block => {
            // Si le block a une heure et une date, g√©n√©rer le titre automatique
            if (block.hitTime || block.scheduledDate) {
                block.title = this.generateAutoTitle(block.hitTime, block.scheduledDate);
            } else if (!block.title || block.title === 'Nouveau Journal') {
                // Si pas de titre ou ancien titre par d√©faut, mettre "Journal"
                block.title = 'Journal';
            }
            return block;
        });
        this.emit('blocks-changed', this.blocks);
    }

    getBlocks() {
        return this.blocks;
    }

    getBlock(blockId) {
        return this.blocks.find(b => b.id === blockId);
    }
    
    getBlockById(blockId) {
        return this.blocks.find(b => b.id === parseInt(blockId));
    }

    create() {
        const today = new Date().toISOString().split('T')[0];
        const newBlock = {
            id: Date.now(),
            title: 'Journal', // Titre temporaire, sera mis √† jour automatiquement
            author: '',
            plannedDuration: '5:00',
            hitTime: '',
            color: '#00ff9f',
            description: '',
            items: [],
            collapsed: false,
            scheduledDate: today,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };
        
        this.blocks.push(newBlock);
        this.currentBlockId = newBlock.id;
        
        this.emit('block-created', newBlock);
        this.emit('blocks-changed', this.blocks);
        this.render();
        this.load(newBlock.id);
        
        return newBlock;
    }
    
    // G√©n√®re automatiquement le titre du journal
    generateAutoTitle(hitTime, scheduledDate) {
        if (!hitTime || !scheduledDate) {
            return 'Journal';
        }
        
        // Formater la date en fran√ßais
        const date = new Date(scheduledDate + 'T00:00:00');
        const options = { day: 'numeric', month: 'long', year: 'numeric' };
        const formattedDate = date.toLocaleDateString('fr-FR', options);
        
        return `Journal de ${hitTime} du ${formattedDate}`;
    }
    
    // Met √† jour le titre automatiquement
    updateAutoTitle() {
        const block = this.getBlock(this.currentBlockId);
        if (!block) return;
        
        const hitTime = safeGetValue('block-hit-time');
        const scheduledDate = safeGetValue('block-scheduled-date');
        
        const autoTitle = this.generateAutoTitle(hitTime, scheduledDate);
        
        // Mettre √† jour l'affichage
        const titleInput = safeGetElement('block-title');
        if (titleInput) {
            titleInput.value = autoTitle;
        }
        
        // Sauvegarder dans le block
        block.title = autoTitle;
        block.hitTime = hitTime;
        block.scheduledDate = scheduledDate;
        
        // Mettre √† jour la liste
        this.render();
        
        // V√©rifier si duplication n√©cessaire pour news multi-journaux
        this.checkNewsMultiJournalDuplication();
    }
    
    // V√©rifie et duplique les news assign√©es √† plusieurs journaux
    checkNewsMultiJournalDuplication() {
        if (!window.app?.newsManager) return;
        
        const newsDatabase = window.app.newsManager.getDatabase();
        const blocksWithTime = this.blocks.filter(b => b.hitTime);
        
        newsDatabase.forEach(news => {
            if (news.assignedBlocks && news.assignedBlocks.length > 1) {
                // Cette news est assign√©e √† plusieurs journaux
                const assignedBlocksWithDifferentTimes = news.assignedBlocks
                    .map(blockId => this.getBlock(parseInt(blockId)))
                    .filter(block => block && block.hitTime)
                    .map(block => block.hitTime)
                    .filter((time, index, self) => self.indexOf(time) === index);
                
                if (assignedBlocksWithDifferentTimes.length > 1) {
                    // Dupliquer la news pour chaque heure diff√©rente
                    this.duplicateNewsForDifferentTimes(news, assignedBlocksWithDifferentTimes);
                }
            }
        });
    }
    
    // Duplique une news pour diff√©rentes heures
    duplicateNewsForDifferentTimes(originalNews, times) {
        if (!window.app?.newsManager) return;
        
        // Pour chaque heure sauf la premi√®re (qui garde l'original)
        times.slice(1).forEach(time => {
            // V√©rifier si une variante existe d√©j√†
            const variantExists = window.app.newsManager.getDatabase().some(news => 
                news.originalId === originalNews.id && news.variantTime === time
            );
            
            if (!variantExists) {
                // Cr√©er une copie de la news
                const newsVariant = {
                    ...originalNews,
                    id: Date.now() + Math.random(),
                    title: `${originalNews.title} (${time})`,
                    originalId: originalNews.id,
                    variantTime: time,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
                
                // Ajouter la variante √† la base de donn√©es
                window.app.newsManager.getDatabase().push(newsVariant);
                
                // Notification
                showNotification(`News dupliqu√©e pour ${time}`, 'info');
            }
        });
        
        // Rafra√Æchir l'affichage
        window.app.newsManager.render();
    }

    load(blockId) {
        const block = this.blocks.find(b => b.id === blockId);
        if (!block) return;

        this.currentBlockId = blockId;
        
        // Update form fields
        this.populateForm(block);
        
        // Update UI
        this.updateActiveState(blockId);
        this.renderBlockItems();
        this.calculateBlockDuration();
        
        // Show editor
        this.showEditor();
        
        // R√©-attacher les event listeners pour la mise √† jour automatique du titre
        this.attachTitleListeners();
        
        this.emit('block-loaded', block);
    }
    
    // Attache les event listeners pour la mise √† jour automatique du titre
    attachTitleListeners() {
        const hitTimeInput = safeGetElement('block-hit-time');
        const scheduledDateInput = safeGetElement('block-scheduled-date');
        
        if (hitTimeInput && !hitTimeInput.hasAttribute('data-listener-attached')) {
            hitTimeInput.setAttribute('data-listener-attached', 'true');
            hitTimeInput.addEventListener('input', () => {
                this.updateAutoTitle();
            });
        }
        
        if (scheduledDateInput && !scheduledDateInput.hasAttribute('data-listener-attached')) {
            scheduledDateInput.setAttribute('data-listener-attached', 'true');
            scheduledDateInput.addEventListener('input', () => {
                this.updateAutoTitle();
            });
        }
    }

    save() {
        const block = this.getBlock(this.currentBlockId);
        if (!block) return;

        // Update block from form
        const hitTime = safeGetValue('block-hit-time');
        const scheduledDate = safeGetValue('block-scheduled-date');
        
        // G√©n√©rer le titre automatiquement
        block.title = this.generateAutoTitle(hitTime, scheduledDate);
        block.author = safeGetValue('block-author') || '';
        block.plannedDuration = validateDuration(safeGetValue('block-planned-duration'));
        block.hitTime = hitTime;
        block.color = safeGetValue('block-color');
        block.description = safeGetValue('block-description');
        
        // S'assurer que scheduledDate est toujours dans le bon format
        if (scheduledDate) {
            block.scheduledDate = scheduledDate;
        } else if (!block.scheduledDate) {
            // Si pas de date, mettre la date du jour par d√©faut
            block.scheduledDate = new Date().toISOString().split('T')[0];
        }
        block.updatedAt = new Date().toISOString();
        
        // Update conductor if block exists there
        if (window.app?.conductorManager) {
            const segment = window.app.conductorManager.findSegmentByBlockId(block.id);
            if (segment) {
                segment.title = block.title;
                segment.duration = block.plannedDuration;
                segment.blockColor = block.color;
                window.app.conductorManager.render();
            }
        }
        
        // Update the list
        this.render();
        
        // Make sure editor stays visible
        this.showEditor();
        
        // Update active state in the list
        this.updateActiveState(this.currentBlockId);
        
        // Reload the form with updated values to keep the display
        this.populateForm(block);
        
        // Re-render block items to ensure they are displayed
        this.renderBlockItems();
        
        // Recalculate duration to update all displays
        this.calculateBlockDuration();
        
        this.emit('block-saved', block);
        this.emit('blocks-changed', this.blocks);
        showNotification('Journal enregistr√© !', 'success');
    }

    delete() {
        if (!this.currentBlockId || !confirm('Supprimer ce journal ?')) return;

        const block = this.getBlock(this.currentBlockId);
        
        // Remove from blocks
        this.blocks = this.blocks.filter(b => b.id !== this.currentBlockId);
        
        // Remove from conductor
        if (window.app?.conductorManager) {
            window.app.conductorManager.removeSegmentByBlockId(this.currentBlockId);
        }
        
        // Update UI
        this.currentBlockId = null;
        this.clearEditor();
        this.render();
        
        this.emit('block-deleted', block);
        this.emit('blocks-changed', this.blocks);
        showNotification('Journal supprim√©', 'warning');
    }

    // Add item to block
    addItem(blockId, itemType, itemId) {
        const block = this.getBlock(blockId);
        if (!block) return;

        // Check if item already in another block
        this.blocks.forEach(b => {
            b.items = b.items.filter(item => 
                !(item.type === itemType && item.id === itemId)
            );
        });

        // Add to block
        block.items.push({
            type: itemType,
            id: itemId,
            order: block.items.length
        });
        
        // Update the item's assignedBlocks array
        if (itemType === 'news' && window.app?.newsManager) {
            const news = window.app.newsManager.getNews(itemId);
            if (news) {
                if (!news.assignedBlocks) {
                    news.assignedBlocks = [];
                }
                if (!news.assignedBlocks.includes(String(blockId))) {
                    news.assignedBlocks.push(String(blockId));
                }
                window.app.newsManager.setDatabase(window.app.newsManager.database);
            }
        } else if (itemType === 'animation' && window.app?.animationManager) {
            const animation = window.app.animationManager.getAnimation(itemId);
            if (animation) {
                if (!animation.assignedBlocks) {
                    animation.assignedBlocks = [];
                }
                if (!animation.assignedBlocks.includes(String(blockId))) {
                    animation.assignedBlocks.push(String(blockId));
                }
                window.app.animationManager.setDatabase(window.app.animationManager.database);
            }
        }

        block.updatedAt = new Date().toISOString();
        
        // Recalculate duration
        this.calculateBlockDuration();
        
        // Update UI
        if (blockId === this.currentBlockId) {
            // Preserve form values before updating
            const currentTitle = safeGetValue('block-title');
            const currentDescription = safeGetValue('block-description');
            this.renderBlockItems();
            // Restore form values if they were cleared
            if (currentTitle) {
                safeSetValue('block-title', currentTitle || block.title);
            }
            if (currentDescription !== undefined) {
                safeSetValue('block-description', currentDescription || block.description || '');
            }
        }
        
        // Close modal if open and refresh the list
        const modal = safeGetElement('block-assign-modal');
        if (modal && modal.classList.contains('active')) {
            this.updateAssignModalContent();
        }
        
        // Update conductor if block is there
        if (window.app?.conductorManager) {
            const segment = window.app.conductorManager.findSegmentByBlockId(blockId);
            if (segment) {
                window.app.conductorManager.render();
            }
        }
        
        // Mettre √† jour le conducteur si le block y est pr√©sent
        this.updateConductorBlock(blockId);
        
        this.emit('block-items-changed', block);
        this.emit('blocks-changed', this.blocks);
        showNotification(`${itemType === 'news' ? 'News' : 'Animation'} ajout√©e au journal`, 'success');
    }

    // Nouvelle m√©thode pour mettre √† jour le conducteur
    updateConductorBlock(blockId) {
        if (!window.app?.conductorManager) return;
        
        const blockSegment = window.app.conductorManager.segments.find(s => s.blockId === blockId);
        if (!blockSegment) return;
        
        const block = this.getBlock(blockId);
        if (!block) return;
        
        // Supprimer les anciens enfants
        window.app.conductorManager.segments = window.app.conductorManager.segments.filter(
            s => s.parentId !== blockSegment.id
        );
        
        // Ajouter les nouveaux enfants
        block.items.forEach(item => {
            if (item.type === 'news') {
                const news = window.app.newsManager.getDatabase().find(n => n.id === item.id);
                if (news) {
                    const calculatedDuration = window.app.newsManager.calculateItemDuration(news);
                    window.app.conductorManager.addSegment({
                        type: 'news',
                        newsId: news.id,
                        title: news.title,
                        duration: news.duration,
                        actualDuration: calculatedDuration,
                        content: news.content,
                        author: news.author
                    }, blockSegment.id);
                }
            } else if (item.type === 'animation') {
                const animation = window.app.animationManager.getDatabase().find(a => a.id === item.id);
                if (animation) {
                    const calculatedDuration = window.app.animationManager.calculateItemDuration(animation);
                    window.app.conductorManager.addSegment({
                        type: 'animation',
                        animationId: animation.id,
                        title: animation.title,
                        duration: animation.duration,
                        actualDuration: calculatedDuration,
                        content: animation.content,
                        author: animation.author
                    }, blockSegment.id);
                }
            }
        });
    }

    removeItem(blockId, itemType, itemId) {
        const block = this.getBlock(blockId);
        if (!block) return;

        block.items = block.items.filter(item => 
            !(item.type === itemType && item.id === itemId)
        );

        // Reorder
        block.items.forEach((item, index) => {
            item.order = index;
        });

        block.updatedAt = new Date().toISOString();
        
        // Recalculate duration
        this.calculateBlockDuration();
        
        // Update UI
        if (blockId === this.currentBlockId) {
            this.renderBlockItems();
        }
        
        // Mettre √† jour le conducteur
        this.updateConductorBlock(blockId);
        
        this.emit('block-items-changed', block);
        this.emit('blocks-changed', this.blocks);
    }

    // UI operations
    render() {
        const container = safeGetElement('blocks-list');
        if (!container) return;

        if (this.blocks.length === 0) {
            container.innerHTML = '<p style="color: #999; text-align: center; padding: 2rem;">No blocks created yet</p>';
            return;
        }

        container.innerHTML = this.blocks.map(block => {
            const actualDuration = this.calculateBlockDurationSync(block);
            const itemCount = block.items.length;
            // G√©n√©rer le titre automatique pour l'affichage
            const displayTitle = this.generateAutoTitle(block.hitTime, block.scheduledDate);
            
            return `
                <div class="block-item ${block.id === this.currentBlockId ? 'active' : ''}" 
                     data-block-id="${block.id}" 
                     onclick="app.blockManager.load(${block.id})"
                     style="border-left-color: ${block.color};">
                    <div class="flex justify-between items-center">
                        <div>
                            <h3 style="display: flex; align-items: center; gap: 0.5rem;">
                                <span style="width: 16px; height: 16px; background-color: ${block.color}; 
                                             border-radius: 3px; display: inline-block;"></span>
                                ${sanitizeHTML(displayTitle)}
                            </h3>
                            <div class="meta">
                                ${block.author ? `<strong>${sanitizeHTML(block.author)}</strong> ‚Ä¢ ` : ''}
                                Pr√©vu : ${block.plannedDuration} ‚Ä¢ R√©el : ${actualDuration} ‚Ä¢ 
                                ${itemCount} √©l√©ment${itemCount !== 1 ? 's' : ''}
                                ${block.hitTime ? ` ‚Ä¢ Diffusion : ${block.hitTime}` : ''}
                                ${block.scheduledDate ? ` ‚Ä¢ Date : ${new Date(block.scheduledDate).toLocaleDateString('fr-FR')}` : ''}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }).join('');
    }

    populateForm(block) {
        // D'abord remplir les champs
        safeSetValue('block-author', block.author || '');
        safeSetValue('block-planned-duration', block.plannedDuration || '5:00');
        safeSetValue('block-hit-time', block.hitTime || '');
        safeSetValue('block-color', block.color);
        safeSetValue('block-description', block.description || '');
        safeSetValue('block-scheduled-date', block.scheduledDate || new Date().toISOString().split('T')[0]);
        
        // Ensuite g√©n√©rer et afficher le titre automatique
        const autoTitle = this.generateAutoTitle(block.hitTime || '', block.scheduledDate || new Date().toISOString().split('T')[0]);
        safeSetValue('block-title', autoTitle);
        
        const actualDurationEl = safeGetElement('block-actual-duration');
        if (actualDurationEl) {
            actualDurationEl.textContent = this.calculateBlockDurationSync(block);
        }
        
        // Add event listener for planned duration field if not already added
        const plannedDurationInput = safeGetElement('block-planned-duration');
        if (plannedDurationInput && !plannedDurationInput.hasAttribute('data-listener-added')) {
            plannedDurationInput.setAttribute('data-listener-added', 'true');
            plannedDurationInput.addEventListener('input', () => {
                this.calculateBlockDuration();
            });
        }
        
        // Add event listener for description field to recalculate duration on text change
        const descriptionInput = safeGetElement('block-description');
        if (descriptionInput && !descriptionInput.hasAttribute('data-listener-added')) {
            descriptionInput.setAttribute('data-listener-added', 'true');
            descriptionInput.addEventListener('input', Utils.debounce(() => {
                this.calculateBlockDuration();
            }, 300));
        }
        
        // Trigger full duration calculation to update all displays
        this.calculateBlockDuration();
    }

    showEditor() {
        const welcomeEl = safeGetElement('blocks-welcome');
        const editorEl = safeGetElement('blocks-editor');
        if (welcomeEl) welcomeEl.classList.add('hidden');
        if (editorEl) editorEl.classList.remove('hidden');
    }

    clearEditor() {
        const welcomeEl = safeGetElement('blocks-welcome');
        const editorEl = safeGetElement('blocks-editor');
        if (welcomeEl) welcomeEl.classList.remove('hidden');
        if (editorEl) editorEl.classList.add('hidden');
    }

    updateActiveState(blockId) {
        document.querySelectorAll('.block-item').forEach(el => {
            el.classList.toggle('active', el.dataset.blockId == blockId);
        });
    }

    // Calculate block duration
    calculateBlockDuration() {
        const block = this.getBlock(this.currentBlockId);
        if (!block) return;
        
        // Get current description from input field for real-time calculation
        const currentDescription = safeGetValue('block-description');
        if (currentDescription !== undefined) {
            block.description = currentDescription;
        }

        const actualDuration = this.calculateBlockDurationSync(block);
        
        // Update actual duration display
        const actualDurationEl = safeGetElement('block-actual-duration');
        if (actualDurationEl) {
            actualDurationEl.textContent = actualDuration;
        }
        
        // Update total duration display
        const totalDurationEl = safeGetElement('block-total-duration');
        if (totalDurationEl) {
            totalDurationEl.textContent = actualDuration;
        }
        
        // Update planned display - get current value from input field
        const plannedDisplayEl = safeGetElement('block-planned-display');
        const plannedInputEl = safeGetElement('block-planned-duration');
        if (plannedDisplayEl) {
            const currentPlannedValue = plannedInputEl ? plannedInputEl.value : block.plannedDuration;
            plannedDisplayEl.textContent = currentPlannedValue || block.plannedDuration || '0:00';
        }
        
        // Update actual display
        const actualDisplayEl = safeGetElement('block-actual-display');
        if (actualDisplayEl) {
            actualDisplayEl.textContent = actualDuration;
        }
        
        // Calculate and update difference using current input value
        const currentPlannedDuration = plannedInputEl ? plannedInputEl.value : block.plannedDuration;
        const plannedSeconds = Utils.parseDuration(currentPlannedDuration || block.plannedDuration || '0:00');
        const actualSeconds = Utils.parseDuration(actualDuration);
        const differenceSeconds = actualSeconds - plannedSeconds;
        
        const differenceDisplayEl = safeGetElement('block-difference-display');
        if (differenceDisplayEl) {
            const absDiff = Math.abs(differenceSeconds);
            const diffMinutes = Math.floor(absDiff / 60);
            const diffSeconds = absDiff % 60;
            const prefix = differenceSeconds > 0 ? '+' : '-';
            differenceDisplayEl.textContent = `${prefix}${diffMinutes}:${diffSeconds.toString().padStart(2, '0')}`;
            differenceDisplayEl.style.color = differenceSeconds > 0 ? '#00ff00' : '#ff6b6b';
        }
    }

    calculateBlockDurationSync(block) {
        let totalSeconds = 0;
        
        // Calculate duration of assigned items
        if (block.items && block.items.length > 0) {
            block.items.forEach(item => {
                let duration = '0:00';
                
                if (item.type === 'news') {
                    const news = window.app?.newsManager?.getDatabase()?.find(n => n.id === item.id);
                    if (news) {
                        duration = window.app.newsManager.calculateItemDuration(news);
                    }
                } else if (item.type === 'animation') {
                    const animation = window.app?.animationManager?.getDatabase()?.find(a => a.id === item.id);
                    if (animation) {
                        duration = window.app.animationManager.calculateItemDuration(animation);
                    }
                }
                
                totalSeconds += Utils.parseDuration(duration);
            });
        }
        
        // Add duration from block description/summary if present
        const descriptionText = block.description || safeGetValue('block-description') || '';
        if (descriptionText.trim()) {
            // Calculate reading time (assuming ~180 words per minute for French)
            const words = descriptionText.trim().split(/\s+/).length;
            const readingSeconds = Math.ceil((words / 180) * 60);
            totalSeconds += readingSeconds;
            
            // Update word count display if element exists
            const wordCountEl = safeGetElement('block-description-word-count');
            if (wordCountEl) {
                wordCountEl.textContent = `(${words} mot${words !== 1 ? 's' : ''})`;
            }
        } else {
            // Reset word count if no text
            const wordCountEl = safeGetElement('block-description-word-count');
            if (wordCountEl) {
                wordCountEl.textContent = '(0 mots)';
            }
        }

        return formatDurationFromSeconds(totalSeconds);
    }

    // Render block items
    renderBlockItems() {
        const block = this.getBlock(this.currentBlockId);
        const container = safeGetElement('block-assigned-items');
        const listContainer = safeGetElement('block-items-list');
        
        if (!block) return;

        // Use the container specified in the HTML editor
        const targetContainer = container || listContainer;
        if (!targetContainer) return;

        if (!block.items || block.items.length === 0) {
            targetContainer.innerHTML = '<p style="color: #999; text-align: center;">Aucun √©l√©ment assign√©</p>';
            return;
        }

        const newsDb = window.app?.newsManager?.getDatabase() || [];
        const animationDb = window.app?.animationManager?.getDatabase() || [];

        targetContainer.innerHTML = block.items
            .sort((a, b) => a.order - b.order)
            .map(item => {
                let title = 'Inconnu';
                let duration = '0:00';
                let author = '';
                let icon = '';
                
                if (item.type === 'news') {
                    const news = newsDb.find(n => n.id === item.id);
                    if (news) {
                        title = news.title;
                        duration = window.app.newsManager.calculateItemDuration(news);
                        author = news.author;
                        icon = 'üì∞';
                    }
                } else if (item.type === 'animation') {
                    const animation = animationDb.find(a => a.id === item.id);
                    if (animation) {
                        title = animation.title;
                        duration = window.app.animationManager.calculateItemDuration(animation);
                        author = animation.author;
                        icon = 'üéôÔ∏è';
                    }
                }
                
                return `
                    <div class="assigned-item">
                        <div class="assigned-item-info">
                            <span class="assigned-item-type ${item.type}">${item.type}</span>
                            <span>${sanitizeHTML(title)}</span>
                            <span class="assigned-item-duration">${duration}</span>
                        </div>
                        <button class="assigned-item-remove" onclick="app.blockManager.removeItem(${block.id}, '${item.type}', ${item.id})" title="Retirer">
                            ‚úï
                        </button>
                    </div>
                `;
            }).join('');
    }

    // Get available items not in any block
    getAvailableItems() {
        const newsDb = window.app?.newsManager?.getDatabase() || [];
        const animationDb = window.app?.animationManager?.getDatabase() || [];
        
        // Get all items already in blocks
        const usedItems = new Set();
        this.blocks.forEach(block => {
            block.items.forEach(item => {
                usedItems.add(`${item.type}-${item.id}`);
            });
        });
        
        const availableNews = newsDb.filter(news => !usedItems.has(`news-${news.id}`));
        const availableAnimations = animationDb.filter(animation => !usedItems.has(`animation-${animation.id}`));
        
        return { news: availableNews, animations: availableAnimations };
    }

    // Open assignment modal
    openAssignModal() {
        if (window.app) {
            window.app.openAddItemToBlockModal();
        }
    }
    
    // Update modal content with available items
    updateAssignModalContent() {
        if (!this.currentBlockId) return;
        
        const available = this.getAvailableItems();
        const newsContainer = safeGetElement('block-assign-news');
        const animationsContainer = safeGetElement('block-assign-animations');
        
        if (newsContainer) {
            if (available.news.length === 0) {
                newsContainer.innerHTML = '<p style="color: #999; text-align: center; padding: 1rem;">Aucune news non assign√©e</p>';
            } else {
                newsContainer.innerHTML = available.news.map(news => `
                    <div class="assign-item" onclick="app.blockManager.addItem(${this.currentBlockId}, 'news', ${news.id})">
                        <div>
                            <strong>${sanitizeHTML(news.title)}</strong>
                            <span style="color: #999; margin-left: 0.5rem;">${news.duration}</span>
                        </div>
                        <span style="color: #666; font-size: 0.875rem;">${sanitizeHTML(news.author)}</span>
                    </div>
                `).join('');
            }
        }
        
        if (animationsContainer) {
            if (available.animations.length === 0) {
                animationsContainer.innerHTML = '<p style="color: #999; text-align: center; padding: 1rem;">Aucune animation non assign√©e</p>';
            } else {
                animationsContainer.innerHTML = available.animations.map(animation => `
                    <div class="assign-item" onclick="app.blockManager.addItem(${this.currentBlockId}, 'animation', ${animation.id})">
                        <div>
                            <strong>${sanitizeHTML(animation.title)}</strong>
                            <span style="color: #999; margin-left: 0.5rem;">${animation.duration}</span>
                        </div>
                        <span style="color: #666; font-size: 0.875rem;">${sanitizeHTML(animation.author)}</span>
                    </div>
                `).join('');
            }
        }
    }

    // Export blocks for conductor
    exportToConductor(blockId = null) {
        const block = this.getBlock(blockId || this.currentBlockId);
        if (!block) return;

        const segment = {
            type: 'block',
            blockId: block.id,
            title: block.title,
            duration: block.plannedDuration,
            actualDuration: this.calculateBlockDurationSync(block),
            blockColor: block.color,
            children: []
        };

        // Add children
        const newsDb = window.app?.newsManager?.getDatabase() || [];
        const animationDb = window.app?.animationManager?.getDatabase() || [];
        
        block.items.forEach(item => {
            if (item.type === 'news') {
                const news = newsDb.find(n => n.id === item.id);
                if (news) {
                    segment.children.push({
                        type: 'news',
                        newsId: news.id,
                        title: news.title,
                        duration: news.duration,
                        actualDuration: window.app.newsManager.calculateItemDuration(news),
                        content: news.content,
                        author: news.author
                    });
                }
            } else if (item.type === 'animation') {
                const animation = animationDb.find(a => a.id === item.id);
                if (animation) {
                    segment.children.push({
                        type: 'animation',
                        animationId: animation.id,
                        title: animation.title,
                        duration: animation.duration,
                        actualDuration: window.app.animationManager.calculateItemDuration(animation),
                        content: animation.content,
                        author: animation.author
                    });
                }
            }
        });

        return segment;
    }
}

// Export global
window.BlockManager = BlockManager;